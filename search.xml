<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Calibre 使用记录</title>
    <url>/2022/04/03/Calibre-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>使用 <span class="exturl" data-url="aHR0cHM6Ly9jYWxpYnJlLWVib29rLmNvbS9kb3dubG9hZA==">Calibre<i class="fa fa-external-link-alt"></i></span> 管理电子书</p>
<span id="more"></span>

<h2 id="从豆瓣下载书的元数据"><a href="#从豆瓣下载书的元数据" class="headerlink" title="从豆瓣下载书的元数据"></a>从豆瓣下载书的元数据</h2><p>安装插件 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Z1Z2FyeS9jYWxpYnJlLWRvdWJhbg==">calibre-douban<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>常用软件</category>
      </categories>
      <tags>
        <tag>常用软件</tag>
        <tag>calibre</tag>
      </tags>
  </entry>
  <entry>
    <title>Github+Hexo+Next 搭建记录摘要</title>
    <url>/2020/11/23/Github-Hexo-Next-%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95%E6%91%98%E8%A6%81/</url>
    <content><![CDATA[<p>Ubuntu 18.04，Node.js v12.18.2 下 Github+Hexo+Next 的搭建记录摘要</p>
<span id="more"></span>

<h2 id="2022-05-05-00-47-45-更新"><a href="#2022-05-05-00-47-45-更新" class="headerlink" title="2022-05-05 00:47:45 更新"></a>2022-05-05 00:47:45 更新</h2><ul>
<li>升级依赖，主要是 hexo 到 6.1.0</li>
<li>评论系统改用 gitalk</li>
<li>相关博文推荐插件去掉 hexo-related-popular-posts ，改用 hexo-related-posts</li>
<li>增加配置，解决 markdown 中图片路径不正确问题<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">marked:</span></span><br><span class="line"><span class="attr">prependRoot:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">postAsset:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="基础安装和配置"><a href="#基础安装和配置" class="headerlink" title="基础安装和配置"></a>基础安装和配置</h2><ol>
<li>安装依赖</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 实际安装 hexo-cli: 4.2.0</span></span><br><span class="line">npm install -g hexo-cli --registry=https://registry.npm.taobao.org</span><br><span class="line">hexo init ilyydy.github.io --no-install</span><br><span class="line"><span class="built_in">cd</span> ilyydy.github.io</span><br><span class="line"><span class="comment"># 实际安装 hexo: 5.2.0</span></span><br><span class="line">npm install --registry=https://registry.npm.taobao.org</span><br><span class="line"><span class="comment"># 实际安装 next 8.0.2</span></span><br><span class="line">npm install hexo-theme-next --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改站点配置文件 <code>_config.yml</code></li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">野草</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">目的虽有，道路却无；我们所称之为路的，无非是踌躇</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">学习</span> <span class="string">思考</span> <span class="string">技术</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">张生</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 博客网址</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://ilyydy.github.io/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新文章时自动创建一个同名的资源文件夹，存放与该文章有关的资源</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># markdown 图片路径解析， hexo-renderer-marked 3.1.0 以后支持</span></span><br><span class="line"><span class="comment"># source/_posts/foo.md 中 `![](image.jpg)` 将被认为位于 `source/_posts/foo/image.jpg`</span></span><br><span class="line"><span class="attr">marked:</span></span><br><span class="line">  <span class="attr">prependRoot:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">postAsset:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 Next</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署</span></span><br><span class="line"><span class="comment"># 需要先在 Github 上建立和配置对应 Repo</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="comment">#对应仓库的SSH地址（可以在GitHub对应的仓库中复制）</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:ilyydy/ilyydy.github.io.git</span></span><br><span class="line">  <span class="comment">#（分支：User Pages为master，Project Pages为gh-pages）</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>查看效果<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br><span class="line"><span class="comment"># 浏览器访问 localhost:4000 查看效果</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Next-基本配置"><a href="#Next-基本配置" class="headerlink" title="Next 基本配置"></a>Next 基本配置</h2><ol>
<li><p>准备 _config.next.yml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> node_modules/hexo-theme-next/_config.yml _config.next.yml</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>_config.next.yml</code> 简单配置</p>
</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 风格</span></span><br><span class="line"><span class="comment"># scheme: Muse</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 知识共享</span></span><br><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 菜单</span></span><br><span class="line"><span class="comment"># about，tags，categories，commonweal 需要手动创建页面</span></span><br><span class="line"><span class="comment"># https://theme-next.js.org/docs/theme-settings/custom-pages.html</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="attr">commonweal:</span> <span class="string">/404/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-heartbeat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 头像</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># 图片路径</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/avatar.jpg</span></span><br><span class="line">  <span class="comment"># 圆角</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># favicon</span></span><br><span class="line"><span class="comment"># https://realfavicongenerator.net/</span></span><br><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/favicon-16x16.png</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/favicon-32x32.png</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/images/apple-touch-icon.png</span></span><br><span class="line">  <span class="attr">safari_pinned_tab:</span> <span class="string">/images/safari-pinned-tab.svg</span></span><br><span class="line">  <span class="attr">android_manifest:</span> <span class="string">/images/site.webmanifest.json</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 社交链接</span></span><br><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/ilyydy</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">  <span class="attr">E-Mail:</span> <span class="string">mailto:ilyydy@gmail.com</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-envelope</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 社交链接图标</span></span><br><span class="line"><span class="attr">social_icons:</span></span><br><span class="line">  <span class="attr">icons_only:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">transition:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 站点起始时间</span></span><br><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">since:</span> <span class="number">2020</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 标签前缀图标</span></span><br><span class="line"><span class="attr">tag_icon:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">preconnect:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mobile_layout_economy:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 代码块</span></span><br><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">atom-one-dark</span></span><br><span class="line">    <span class="attr">dark:</span> <span class="string">atom-one-dark</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 阅读进度条</span></span><br><span class="line"><span class="attr">reading_progress:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字体</span></span><br><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">https://fonts.loli.net</span></span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Roboto,</span> <span class="string">Noto</span> <span class="string">Serif</span> <span class="string">SC,</span> <span class="string">PingFang</span> <span class="string">SC,</span> <span class="string">Microsoft</span> <span class="string">YaHei,</span> <span class="string">sans-serif</span></span><br><span class="line">  <span class="attr">codes:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Cascadia</span> <span class="string">Code,</span> <span class="string">consolas,</span> <span class="string">Menlo,</span> <span class="string">monospace</span></span><br><span class="line"></span><br><span class="line"><span class="attr">disable_baidu_transformation:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">exturl:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">pjax:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">fancybox:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">lazyload:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">pangu:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">quicklink:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 博文评分</span></span><br><span class="line"><span class="comment"># https://theme-next.js.org/docs/third-party-services/post-widgets.html#Widgetpack-Rating</span></span><br><span class="line"><span class="attr">rating:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">id:</span>     <span class="string">xxxx</span></span><br><span class="line">  <span class="attr">color:</span>  <span class="string">&quot;#fc6423&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># https://theme-next.js.org/docs/third-party-services/post-widgets.html#AddThis</span></span><br><span class="line"><span class="attr">add_this_id:</span>  <span class="string">xxxx</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第三方服务配置"><a href="#第三方服务配置" class="headerlink" title="第三方服务配置"></a>第三方服务配置</h2><ol>
<li>安装依赖</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># RSS</span></span><br><span class="line">npm install hexo-generator-feed --save --registry=https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line"><span class="comment"># 阅读时间、字数</span></span><br><span class="line">npm install hexo-word-counter --save --registry=https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line"><span class="comment"># 相关博文推荐</span></span><br><span class="line">npm install hexo-related-popular-posts --save --registry=https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line"><span class="comment"># 站内搜索</span></span><br><span class="line">npm install hexo-generator-searchdb --registry=https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回到顶部、末尾</span></span><br><span class="line">npm install hexo-cake-moon-menu --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改 <code>_config.yml</code></li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 阅读时间、字数</span></span><br><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">exclude_codeblock:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">300</span></span><br><span class="line">  <span class="attr">suffix:</span> <span class="string">&quot;mins.&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>修改 <code>_config.next.yml</code></li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># RSS</span></span><br><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">RSS:</span> <span class="string">/atom.xml</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-rss</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 相关博文推荐</span></span><br><span class="line"><span class="attr">related_posts:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 站内搜索</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">back2top:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 评论系统</span></span><br><span class="line"><span class="comment"># https://theme-next.js.org/docs/third-party-services/comments.html#Valine-China</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">appId:</span> <span class="string">xxxxxxxxxxxxx</span></span><br><span class="line">  <span class="attr">appKey:</span> <span class="string">xxxxxxxxxxxx</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">留下你的邮箱可以更快得到回复！</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">requiredFields:</span> [<span class="string">&#x27;nick&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="样式修改"><a href="#样式修改" class="headerlink" title="样式修改"></a>样式修改</h2><ul>
<li><p><code>source/_data/styles.styl</code></p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Hide Sidebar on Mobile</span></span><br><span class="line">+<span class="built_in">tablet-mobile</span>() &#123;</span><br><span class="line">  <span class="selector-class">.sidebar-toggle</span>, <span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#202020</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.post</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  -webkit-<span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> rgba(<span class="number">202</span>, <span class="number">203</span>, <span class="number">203</span>, .<span class="number">5</span>);</span><br><span class="line">  -moz-<span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> rgba(<span class="number">202</span>, <span class="number">203</span>, <span class="number">204</span>, .<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 背景图</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>:url(/images/background.jpg);</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">background-attachment</span>:fixed; <span class="comment">//不重复</span></span><br><span class="line">  <span class="attribute">background-size</span>: cover;      <span class="comment">//填充</span></span><br><span class="line">  <span class="attribute">background-position</span>:<span class="number">50%</span> <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//博客内容透明化</span></span><br><span class="line"><span class="comment">//文章内容的透明度设置</span></span><br><span class="line"><span class="selector-class">.main-inner</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//侧边框的透明度设置</span></span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 站点概况的透明度设置</span></span><br><span class="line"><span class="selector-class">.sidebar-inner</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//菜单栏的透明度设置</span></span><br><span class="line"><span class="selector-class">.header-inner</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: rgba(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//搜索框（local-search）的透明度设置</span></span><br><span class="line"><span class="selector-class">.popup</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>source/_data/variables.styl</code></p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 圆角设置</span></span><br><span class="line"><span class="variable">$border</span>-radius-inner     = <span class="number">20px</span> <span class="number">20px</span> <span class="number">20px</span> <span class="number">20px</span>;</span><br><span class="line"><span class="variable">$border</span>-radius           = <span class="number">20px</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>_config.next.yml</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="attr">variable:</span> <span class="string">source/_data/variables.styl</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.Js MonoRepo 方案</title>
    <url>/2022/08/10/Node-Js-MonoRepo-%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9tb25vcmVwby50b29scy8=">monorepo.tools<i class="fa fa-external-link-alt"></i></span> 介绍和对比了一些主流的解决方案，其中和 js&#x2F;ts 生态联系紧密主要是 Lerna，Nx，Turborepo，Rush。研究了这几种方案的文档和入门使用，再看了看几位开发者的介绍和评价。总结它们的优缺点如下：</p>
<span id="more"></span>

<h2 id="lerna"><a href="#lerna" class="headerlink" title="lerna"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xlcm5hL2xlcm5h">lerna<i class="fa fa-external-link-alt"></i></span></h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>具备依赖管理能力（实际一般使用包管理器的 workspace 功能）</li>
<li>具备版本管理和发布能力</li>
<li>具备任务编排能力</li>
<li>已经被 Nx 团队接手，容易与 nx 集成</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>package 多任务执行时会慢。可与 nx 集成优化</li>
<li>使用 lerna bootstrap 安装部分 package 的依赖的命令长，比较麻烦</li>
<li>每个 package 各自安装依赖，重复，并且慢。可以结合 pnpm 解决</li>
<li>使用 root node_modules 和依赖提升存在 Phantom Dependencies 和 Doppelgnger。可以结合 pnpm 解决</li>
<li>lerna 和包管理器的命令不统一</li>
</ul>
<p>总结：lerna + 包管理器 workspace 是目前应用最多、较为轻量的 monorepo 方案，容易上手，适合小型 monorepo。大型 monorepo 项目考虑集成 nx 增强任务编排能力</p>
<h2 id="Nx"><a href="#Nx" class="headerlink" title="Nx"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25yd2wvbng=">Nx<i class="fa fa-external-link-alt"></i></span></h2><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>优秀的任务编排，计算缓存，增量构建，分布式任务执行</li>
<li>更深入的依赖和 package 关系分析，可视化依赖图，增强 package 间的引用约束</li>
<li>生态丰富：各类框架&#x2F;工具集成，代码快速生成，自定义执行器</li>
<li>全工作流命令统一，支持自定义任务&#x2F;命令</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>倾向于所有 package 共用同一份 package.json 和 root node_modules，前后端项目会共用依赖，所以也不需要依赖管理能力</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ueC5kZXYvbWlncmF0aW9uL2xlcm5hLWFuZC1ueCN2ZXJzaW9uLW1hbmFnZW1lbnQtJi1wdWJsaXNoaW5n">没有版本管理和发布<i class="fa fa-external-link-alt"></i></span>，可以使用插件或与 lerna 集成</li>
<li>本身不解决 Phantom Dependencies 和 Doppelgnger。可以结合 pnpm 解决</li>
</ul>
<p>总结：功能强大，扩展性强，使用热度高，社区插件丰富，唯一的问题是使用 root node_modules 方案</p>
<h2 id="Turborepo"><a href="#Turborepo" class="headerlink" title="Turborepo"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC90dXJib3JlcG8=">Turborepo<i class="fa fa-external-link-alt"></i></span></h2><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul>
<li>优秀的任务编排，计算缓存，增量构建，分布式任务执行</li>
<li>许多命令支持分析依赖和 package 关系，如按需安装依赖，支持可视化分析</li>
<li>一系列可选的配套工具链</li>
</ul>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>没有依赖管理能力，和包管理器的命令不统一</li>
<li>没有版本管理和发布。可以使用配置工具链</li>
<li>本身不解决 Phantom Dependencies 和 Doppelgnger。依赖包管理器解决</li>
<li>filter package 的命令可以很灵活，但相对书写也比较麻烦</li>
</ul>
<p>总结：turborepo + 包管理器 workspace 优于 lerna + 包管理器 workspace。生态相对 Nx 较弱，但也够用</p>
<h2 id="Rush"><a href="#Rush" class="headerlink" title="Rush"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9ydXNoc3RhY2s=">Rush<i class="fa fa-external-link-alt"></i></span></h2><h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><ul>
<li>具备依赖管理能力</li>
<li>优秀的任务编排，计算缓存，增量构建，分布式任务执行</li>
<li>支持依赖和 package 关系分析，保证版本一致性</li>
<li>全工作流命令统一，支持自定义任务&#x2F;命令</li>
<li>解决 Phantom Dependencies</li>
<li>可选的全套工具链</li>
</ul>
<h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>没有 root node_modules。可通过配套工具链统一配置解决</li>
<li>本身不解决 Doppelgnger。需通过 pnpm 解决</li>
<li>新增 package 需要手动编辑 rush.json</li>
<li>可选的配套工具链配置复杂</li>
<li>文档更新不及时</li>
</ul>
<p>总结：功能强大，扩展性强，加上配套工具链则具备一整套工作流的解决方案，相对得使用成本高，适合大型 monorepo</p>
<h2 id="monorepo-工具应具备的能力"><a href="#monorepo-工具应具备的能力" class="headerlink" title="monorepo 工具应具备的能力"></a>monorepo 工具应具备的能力</h2><ol>
<li>依赖管理能力，特对每个 package 的依赖的处理。随着依赖数量的增加，依旧能够保持依赖结构的正确性、稳定性以及安装效率，避免 Phantom Dependencies 和 Doppelgnger 问题</li>
<li>package 关系分析能力，构造展现 package 之间的依赖关系，一方面方便开发者理清整个 monorepo 的结构，另一方面可用于优化任务编排<br /></li>
<li>任务编排能力。能够以最大的效率以及正确的顺序执行 monorepo 内任务&#x2F;命令</li>
<li>版本发布能力。能够基于改动的项目，结合 package 的关系，正确地进行版本号变更、CHANGELOG 生成以及项目发布</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82OTcyMTM5ODcwMjMxNzI0MDQ1">Monorepo 的这些坑，我们帮你踩过了！<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81MDQ1NTQwNzA=">Monorepo 的过去、现在、和未来<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81MjEwNjA5ODY=">现代 Monorepo 工程技术选型，聊聊我的思考<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80NjgzODI3NTY=">从 Turborepo 看 Monorepo 工具的任务编排能力<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMzc1MzU3Nzk=">node_modules 困境<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>MonoRepo</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 泛型型变篇</title>
    <url>/2020/12/04/TypeScript-%E6%B3%9B%E5%9E%8B%E5%9E%8B%E5%8F%98%E7%AF%87/</url>
    <content><![CDATA[<p>介绍 TypeScript 泛型的型变</p>
<p>Github Repo 地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lseXlkeS90eXBlc2NyaXB0LWdlbmVyaWM=">https://github.com/ilyydy/typescript-generic<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>

<h1 id="型变-variance"><a href="#型变-variance" class="headerlink" title="型变 variance"></a>型变 variance</h1><p><code>Variance refers to how subtyping between more complex types relates to subtyping between their components.</code></p>
<p>对于类型 A 和 B，如果 B 是 A 的子类型(subtype)，记作 <code>B &lt;: A</code></p>
<p>对于一个类型构造器 <code>F&lt;T&gt;</code>，它是：</p>
<ul>
<li>协变(covariant): 当 <code>B &lt;: A</code> 且 <code>F&lt;B&gt; &lt;: F&lt;A&gt;</code></li>
<li>逆变(contravariant): 当 <code>B &lt;: A</code> 且 <code>F&lt;A&gt; &lt;: F&lt;B&gt;</code></li>
<li>双变(bivariant): 当 <code>B &lt;: A</code> 且 <code>F&lt;A&gt; &lt;: F&lt;B&gt;</code>、<code>F&lt;B&gt; &lt;: F&lt;A&gt;</code></li>
<li>不变(invariant): 以上以外的情况</li>
</ul>
<h2 id="协变和逆变"><a href="#协变和逆变" class="headerlink" title="协变和逆变"></a>协变和逆变</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/6.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Animal</span> = &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Cat</span> = <span class="title class_">Animal</span> &amp; &#123;</span><br><span class="line">    <span class="attr">meow</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">animal</span>: <span class="title class_">Animal</span> = &#123; <span class="attr">age</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">cat</span>: <span class="title class_">Cat</span> = &#123; <span class="attr">age</span>: <span class="number">2</span>, <span class="attr">meow</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;meow&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cat 是 Animal 的子类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">expectAnimal</span>: <span class="title class_">Animal</span> = cat <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">expectCat</span>: <span class="title class_">Cat</span> = animal <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AnimalList</span> = <span class="title class_">Animal</span>[]</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">CatList</span> = <span class="title class_">Cat</span>[]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">animalList</span>: <span class="title class_">AnimalList</span> = [animal]</span><br><span class="line"><span class="keyword">const</span> <span class="attr">catList</span>: <span class="title class_">CatList</span> = [cat]</span><br><span class="line"></span><br><span class="line"><span class="comment">// CatList 是 AnimalList 的子类型，数组是型变</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">expectAnimalList</span>: <span class="title class_">AnimalList</span> = catList</span><br><span class="line"><span class="keyword">const</span> <span class="attr">expectCatList</span>: <span class="title class_">CatList</span> = animalList <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Compare</span>&lt;T&gt; = <span class="function">(<span class="params">left: T, right: T</span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">CompareAnimal</span> = <span class="title class_">Compare</span>&lt;<span class="title class_">Animal</span>&gt;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">CompareCat</span> = <span class="title class_">Compare</span>&lt;<span class="title class_">Cat</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">compareAnimal</span>: <span class="title class_">CompareAnimal</span> = <span class="function">(<span class="params">left: Animal, right: Animal</span>) =&gt;</span> left.<span class="property">age</span> - right.<span class="property">age</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">compareCat</span>: <span class="title class_">CompareCat</span> = <span class="function">(<span class="params">left: Cat, right: Cat</span>) =&gt;</span> left.<span class="property">age</span> - right.<span class="property">age</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CompareAnimal 是 CompareCat 的子类型，函数类型的参数是逆变</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">expectCompareAnimal</span>: <span class="title class_">CompareAnimal</span> = compareCat  <span class="comment">// error</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">expectCompareCat</span>: <span class="title class_">CompareCat</span> = compareAnimal</span><br><span class="line"></span><br><span class="line"><span class="comment">// 容易得出函数类型的返回值是协变</span></span><br></pre></td></tr></table></figure>

<h2 id="双变和不变"><a href="#双变和不变" class="headerlink" title="双变和不变"></a>双变和不变</h2><h3 id="双变"><a href="#双变" class="headerlink" title="双变"></a>双变</h3><p>typescript 最开始设计中函数类型的参数是双变</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L3dpa2kvRkFRI3doeS1hcmUtZnVuY3Rpb24tcGFyYW1ldGVycy1iaXZhcmlhbnQ=">why-are-function-parameters-bivariant<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<p>In summary, in the TypeScript type system,<br>the question of whether a more-specific-type-accepting function should be assignable to a function accepting a less-specific type<br>provides a prerequisite answer to whether an array of that more specific type should be assignable to an array of a less specific type.</p>
</blockquote>
<h2 id="数组类型，不变与协变"><a href="#数组类型，不变与协变" class="headerlink" title="数组类型，不变与协变"></a>数组类型，不变与协变</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Dog</span> = <span class="title class_">Animal</span> &amp; &#123;</span><br><span class="line">    <span class="attr">bark</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">dog</span>: <span class="title class_">Dog</span> = &#123; <span class="attr">age</span>: <span class="number">3</span>, <span class="attr">bark</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;bark&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line">expectAnimalList.<span class="title function_">push</span>(dog)</span><br><span class="line">catList.<span class="title function_">forEach</span>(<span class="function"><span class="params">e</span> =&gt;</span> e.<span class="title function_">meow</span>()) <span class="comment">// runtime error, TypeError: e.meow is not a function. 类型不安全</span></span><br></pre></td></tr></table></figure>

<p>从类型安全上讲，<code>Animal[]</code> 与 <code>Cat[]</code> 应该没有父子类型关系，即数组类型是不变。更准确地说： <strong>可写</strong>数组 <strong>不变</strong> 是安全的，<strong>不可写</strong>（只读）数组 <strong>协变</strong> 是安全的。typescript 为了便利性，允许数组类型是协变</p>
<h3 id="strictFunctionTypes"><a href="#strictFunctionTypes" class="headerlink" title="strictFunctionTypes"></a>strictFunctionTypes</h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svcmVsZWFzZS1ub3Rlcy90eXBlc2NyaXB0LTItNi5odG1s">typescript 2.6 增加 strictFunctionTypes<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<p>Under –strictFunctionTypes function type parameter positions are checked contravariantly instead of bivariantly.<br>The stricter checking applies to all function types, except those originating in method or constructor declarations.<br>Methods are excluded specifically to ensure generic classes and interfaces (such as Array<T>) continue to mostly relate covariantly.</p>
</blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L3B1bGwvMTg2NTQ=">Strict function types<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> F1 &#123;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Comparer</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="title function_">compare</span>(<span class="attr">a</span>: T, <span class="attr">b</span>: T): <span class="built_in">number</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">declare</span> <span class="keyword">let</span> <span class="attr">animalComparer</span>: <span class="title class_">Comparer</span>&lt;<span class="title class_">Animal</span>&gt;</span><br><span class="line">    <span class="keyword">declare</span> <span class="keyword">let</span> <span class="attr">dogComparer</span>: <span class="title class_">Comparer</span>&lt;<span class="title class_">Dog</span>&gt;</span><br><span class="line"></span><br><span class="line">    animalComparer = dogComparer <span class="comment">// Ok, T is bivariant in Comparer&lt;T&gt; because it is used only in method parameter positions.</span></span><br><span class="line">    dogComparer = animalComparer <span class="comment">// Ok</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> F2 &#123;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Comparer</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="attr">compare</span>: <span class="function">(<span class="params">a: T, b: T</span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">declare</span> <span class="keyword">let</span> <span class="attr">animalComparer</span>: <span class="title class_">Comparer</span>&lt;<span class="title class_">Animal</span>&gt;</span><br><span class="line">    <span class="keyword">declare</span> <span class="keyword">let</span> <span class="attr">dogComparer</span>: <span class="title class_">Comparer</span>&lt;<span class="title class_">Dog</span>&gt;</span><br><span class="line"></span><br><span class="line">    animalComparer = dogComparer <span class="comment">// Error, T is contravariant in Comparer&lt;T&gt; because it is used only in function type parameter positions.</span></span><br><span class="line">    dogComparer = animalComparer <span class="comment">// Ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="协变＼逆变与类型推断"><a href="#协变＼逆变与类型推断" class="headerlink" title="协变＼逆变与类型推断"></a>协变＼逆变与类型推断</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The following example demonstrates how multiple candidates for the same type variable in co-variant positions causes a union type to be inferred:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span>&lt;T&gt; = T <span class="keyword">extends</span> &#123; <span class="attr">a</span>:　<span class="function">() =&gt;</span> infer U; <span class="attr">b</span>: <span class="function">() =&gt;</span> infer U &#125; ? U : <span class="built_in">never</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T10</span> = <span class="title class_">Foo</span>&lt;&#123; <span class="attr">a</span>: <span class="function">() =&gt;</span> <span class="built_in">string</span>; <span class="attr">b</span>: <span class="function">() =&gt;</span> <span class="built_in">string</span> &#125;&gt; <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T11</span> = <span class="title class_">Foo</span>&lt;&#123; <span class="attr">a</span>: <span class="function">() =&gt;</span> <span class="built_in">string</span>; <span class="attr">b</span>: <span class="function">() =&gt;</span> <span class="built_in">number</span> &#125;&gt; <span class="comment">// string | number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Likewise, multiple candidates for the same type variable in contra-variant positions causes an intersection type to be inferred:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bar</span>&lt;T&gt; = T <span class="keyword">extends</span> &#123; <span class="attr">a</span>: <span class="function">(<span class="params">x: infer U</span>) =&gt;</span> <span class="built_in">void</span>; <span class="attr">b</span>: <span class="function">(<span class="params">x: infer U</span>) =&gt;</span> <span class="built_in">void</span> &#125;</span><br><span class="line">    ? U</span><br><span class="line">    : <span class="built_in">never</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T20</span> = <span class="title class_">Bar</span>&lt;&#123; <span class="attr">a</span>: <span class="function">(<span class="params">x: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>; <span class="attr">b</span>: <span class="function">(<span class="params">x: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span> &#125;&gt; <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T21</span> = <span class="title class_">Bar</span>&lt;&#123; <span class="attr">a</span>: <span class="function">(<span class="params">x: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>; <span class="attr">b</span>: <span class="function">(<span class="params">x: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span> &#125;&gt; <span class="comment">// never</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程</category>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 泛型基础篇</title>
    <url>/2020/12/04/TypeScript-%E6%B3%9B%E5%9E%8B%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<p>介绍 TypeScript 泛型的基础常用知识和用法</p>
<p>Github Repo 地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lseXlkeS90eXBlc2NyaXB0LWdlbmVyaWM=">https://github.com/ilyydy/typescript-generic<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>

<p>目的：</p>
<ol>
<li>创建可复用的组件，一个组件可以支持多种类型的数据</li>
<li>对组件的类型进行约束</li>
</ol>
<p>可用于：</p>
<ul>
<li>函数参数</li>
<li>函数返回值</li>
<li>类的实例成员</li>
<li>类的实例方法</li>
<li>…</li>
</ul>
<p>主要资料：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svZ2VuZXJpY3MuaHRtbA==">typescript: generics<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svYWR2YW5jZWQtdHlwZXMuaHRtbA==">typescript: advanced-types<i class="fa fa-external-link-alt"></i></span>  </li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudHNsYW5nLmNuL2RvY3MvaGFuZGJvb2svZnVuY3Rpb25zLmh0bWw=">typescript: functions<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="构造可复用组件"><a href="#构造可复用组件" class="headerlink" title="构造可复用组件"></a>构造可复用组件</h2><h3 id="用于函数"><a href="#用于函数" class="headerlink" title="用于函数"></a>用于函数</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/0.ts</span></span><br><span class="line"><span class="comment">// 目标为构建 identity 函数： 这个函数会返回任何传入它的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">First</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 参数使用 any, 返回值丢失传入参数的类型</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">identity</span>(<span class="params">arg: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arg</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> r1 = <span class="title function_">identity</span>(<span class="string">&quot;test&quot;</span>) <span class="comment">// any</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">Second</span> &#123;</span><br><span class="line">    <span class="comment">// 2. 使用函数签名的类型重载</span></span><br><span class="line">    <span class="comment">// 编译器根据调用函数时实际传入的参数类型，依次和函数定义进行匹配，直到匹配到第一条合适的</span></span><br><span class="line">    <span class="comment">// 但每种需要的类型都必须写出来</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">identity</span>(<span class="params">arg: <span class="built_in">string</span></span>): <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">identity</span>(<span class="params">arg: <span class="built_in">number</span></span>): <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">identity</span>(<span class="params">arg: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arg</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> r2 = <span class="title function_">identity</span>(<span class="string">&quot;test&quot;</span>) <span class="comment">// string</span></span><br><span class="line">    <span class="keyword">const</span> r3 = <span class="title function_">identity</span>(<span class="number">1</span>) <span class="comment">// number</span></span><br><span class="line">    <span class="keyword">const</span> r4 = <span class="title function_">identity</span>([<span class="number">1</span>]) <span class="comment">// error, No overload matches this call.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">Third</span> &#123;</span><br><span class="line">    <span class="comment">// 3.使用泛型</span></span><br><span class="line">    <span class="keyword">function</span> identity&lt;T&gt;(<span class="attr">arg</span>: T) &#123;</span><br><span class="line">        <span class="keyword">return</span> arg</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式地指明类型参数 T 的类型</span></span><br><span class="line">    <span class="keyword">const</span> output1 = identity&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;myString&quot;</span>) <span class="comment">// type of output will be &#x27;string&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更好的做法：利用了类型推论，编译器会根据传入的参数自动地帮助我们确定 T 的类型</span></span><br><span class="line">    <span class="keyword">const</span> output2 = <span class="title function_">identity</span>(<span class="string">&quot;myString&quot;</span>) <span class="comment">// type of output will be &#x27;myString&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">Forth</span> &#123;</span><br><span class="line">    <span class="comment">// 也可以直接构造函数类型</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">IdentityFunc</span> = &lt;T&gt;<span class="function">(<span class="params">arg: T</span>) =&gt;</span> T</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">identity</span>: <span class="title class_">IdentityFunc</span> = <span class="function">(<span class="params">arg: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arg</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式地指明类型参数 T 的类型</span></span><br><span class="line">    <span class="keyword">const</span> output3 = identity&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;myString&quot;</span>) <span class="comment">// type of output will be &#x27;string&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更好的做法：利用了类型推论，编译器会根据传入的参数自动地帮助我们确定 T 的类型</span></span><br><span class="line">    <span class="keyword">const</span> output4 = <span class="title function_">identity</span>(<span class="string">&quot;myString&quot;</span>) <span class="comment">// type of output will be &#x27;myString&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常用场景：</span></span><br><span class="line"><span class="comment">// 1.通过 axios 从服务端获取数据</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 默认为 any</span></span><br><span class="line">    <span class="keyword">const</span> t1 = <span class="keyword">await</span> A.<span class="title function_">get</span>(<span class="string">&quot;http://someUrl&quot;</span>) <span class="comment">// AxiosResponse&lt;any&gt;</span></span><br><span class="line">    <span class="keyword">const</span> data1 = t1.<span class="property">data</span> <span class="comment">// any</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> t2 = <span class="keyword">await</span> A.<span class="property">get</span>&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;http://someUrl&quot;</span>) <span class="comment">// AxiosResponse&lt;string&gt;</span></span><br><span class="line">    <span class="keyword">const</span> data2 = t2.<span class="property">data</span> <span class="comment">// string</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Template</span>&lt;T&gt; = &#123; <span class="attr">code</span>: <span class="built_in">number</span>; <span class="attr">data</span>: T; <span class="attr">success</span>: <span class="built_in">boolean</span> &#125;</span><br><span class="line">    <span class="keyword">const</span> t3 = <span class="keyword">await</span> A.<span class="property">get</span>&lt;<span class="title class_">Template</span>&lt;<span class="built_in">string</span>&gt;&gt;(<span class="string">&quot;http://someUrl&quot;</span>) <span class="comment">// AxiosResponse&lt;Template&lt;string&gt;&gt;</span></span><br><span class="line">    <span class="keyword">const</span> data3 = t3.<span class="property">data</span> <span class="comment">// Template&lt;string&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2. 通过数据库 client 从数据库获取数据</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> client = <span class="keyword">new</span> <span class="title class_">MongoClient</span>(<span class="string">&quot;someUri&quot;</span>)</span><br><span class="line">    <span class="keyword">const</span> db = client.<span class="title function_">db</span>(<span class="string">&quot;someDb&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> c1 = db.<span class="title function_">collection</span>(<span class="string">&quot;c1&quot;</span>) <span class="comment">// Collection&lt;any&gt;</span></span><br><span class="line">    <span class="keyword">const</span> data1 = <span class="keyword">await</span> c1.<span class="title function_">find</span>(&#123;&#125;).<span class="title function_">toArray</span>() <span class="comment">// any[]</span></span><br><span class="line">    <span class="keyword">const</span> data2 = <span class="keyword">await</span> c1.<span class="property">find</span>&lt;&#123; <span class="attr">id</span>: <span class="built_in">string</span>; <span class="attr">name</span>: <span class="built_in">string</span> &#125;&gt;(&#123;&#125;).<span class="title function_">toArray</span>() <span class="comment">// &#123; id: string; name: string &#125;[]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> c2 = db.<span class="property">collection</span>&lt;&#123; <span class="attr">id</span>: <span class="built_in">string</span>; <span class="attr">name</span>: <span class="built_in">string</span> &#125;&gt;(<span class="string">&quot;c2&quot;</span>) <span class="comment">// Collection&lt;&#123; id: string; name: string &#125;&gt;</span></span><br><span class="line">    <span class="keyword">const</span> data3 = <span class="keyword">await</span> c2.<span class="title function_">find</span>(&#123;&#125;).<span class="title function_">toArray</span>() <span class="comment">// &#123; id: string; name: string &#125;[]，而且能对 query 进行提示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用于类"><a href="#用于类" class="headerlink" title="用于类"></a>用于类</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue1</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">data</span>: T[] = []</span><br><span class="line"></span><br><span class="line">    <span class="title function_">push</span>(<span class="params">item: T</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">push</span>(item)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">shift</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">shift</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> queue = <span class="keyword">new</span> <span class="title class_">Queue1</span>&lt;<span class="built_in">number</span>&gt;()</span><br><span class="line">queue.<span class="title function_">push</span>(<span class="number">0</span>)</span><br><span class="line">queue.<span class="title function_">push</span>(<span class="string">&quot;1&quot;</span>) <span class="comment">// Error：不能推入一个 `string`，只有 number 类型被允许</span></span><br><span class="line"><span class="keyword">const</span> last = <span class="keyword">new</span> <span class="title class_">Queue1</span>().<span class="title function_">shift</span>() <span class="comment">// 默认值为 unknown, TypeScript 3.0 引进, 与 any 相对</span></span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类的静态成员不能使用泛型类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue2</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">data</span>: T[] = []</span><br><span class="line"></span><br><span class="line">    <span class="title function_">push</span>(<span class="params">item: T</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">push</span>(item)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">shift</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">shift</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="attr">a</span>: T[] = [] <span class="comment">// error</span></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">f</span>(<span class="params">p: T</span>) &#123; &#125; <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以固定机场为例</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">StationaryV1</span> = &#123; <span class="attr">version</span>: <span class="string">&quot;v1&quot;</span>; <span class="attr">plc</span>: <span class="string">&quot;closed&quot;</span>; <span class="attr">a</span>: <span class="built_in">string</span>; <span class="attr">d</span>: &#123; <span class="attr">e</span>: <span class="built_in">string</span> &#125; &#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">StationaryV2</span> = &#123; <span class="attr">version</span>: <span class="string">&quot;v2&quot;</span>; <span class="attr">plc</span>: <span class="string">&quot;closed&quot;</span>; <span class="attr">b</span>: <span class="built_in">number</span>; <span class="attr">d</span>: &#123; <span class="attr">f</span>: <span class="built_in">number</span> &#125; &#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Stationary</span> = <span class="title class_">StationaryV1</span> | <span class="title class_">StationaryV2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> S1 &#123;</span><br><span class="line">    <span class="comment">// 不使用泛型</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Controller</span> &#123;</span><br><span class="line">        <span class="attr">status</span>: <span class="title class_">Stationary</span> | <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">        <span class="title function_">onData</span>(<span class="params">s: Stationary</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">status</span> = s</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">getPropertyD</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">status</span>) <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">status</span>.<span class="property">d</span> <span class="comment">// ok</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">abstract</span> <span class="title function_">work</span>(): <span class="built_in">void</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ControllerV1</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Controller</span> &#123;</span><br><span class="line">        <span class="title function_">work</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> t = <span class="variable language_">this</span>.<span class="property">status</span> <span class="comment">// StationaryV1 | StationaryV2 | undefined, 需要区分 StationaryV1、StationaryV2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title class_">ControllerV1</span>()</span><br><span class="line">    <span class="keyword">const</span> d = c.<span class="title function_">getPropertyD</span>()  <span class="comment">// &#123; e: string; &#125; | &#123; f: number; &#125; | undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> S2 &#123;</span><br><span class="line">    <span class="comment">// 使用泛型</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Controller</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="attr">status</span>: T | <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">        <span class="title function_">onData</span>(<span class="params">s: T</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">status</span> = s</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">abstract</span> <span class="title function_">work</span>(): <span class="built_in">void</span></span><br><span class="line"></span><br><span class="line">        <span class="title function_">getPropertyD</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">status</span>) <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">status</span>.<span class="property">d</span> <span class="comment">// error, 类型“T”上不存在属性“d”</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ControllerV1</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Controller</span>&lt;<span class="title class_">StationaryV1</span>&gt; &#123;</span><br><span class="line">        <span class="title function_">work</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> t = <span class="variable language_">this</span>.<span class="property">status</span> <span class="comment">// StationaryV1 | undefined, ok</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="用于类型"><a href="#用于类型" class="headerlink" title="用于类型"></a>用于类型</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/0.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Obj</span>&lt;<span class="title class_">One</span>, <span class="title class_">Second</span>&gt; = &#123; [<span class="attr">index</span>: <span class="built_in">string</span>]: [<span class="title class_">One</span>, <span class="title class_">Second</span>] &#125;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">Obj</span>&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt; <span class="comment">// &#123; [index: string]: [string, number] &#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">Obj</span>&lt;<span class="built_in">string</span>[], <span class="built_in">number</span>[]&gt; <span class="comment">// &#123; [index: string]: [string[], number[]] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Producer</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="attr">shift</span>: <span class="function">() =&gt;</span> T | <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> consumeFirst&lt;T&gt;(<span class="attr">arg</span>: <span class="title class_">Producer</span>&lt;T&gt;) &#123;</span><br><span class="line">    <span class="keyword">const</span> first = arg.<span class="title function_">shift</span>()</span><br><span class="line">    <span class="comment">// do something with first</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> first</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> item1 = <span class="title function_">consumeFirst</span>([<span class="number">1</span>]) <span class="comment">// number | undefined</span></span><br><span class="line"><span class="keyword">const</span> item2 = consumeFirst&lt;<span class="built_in">number</span>&gt;(<span class="keyword">new</span> <span class="title class_">Queue1</span>()) <span class="comment">// number | undefined</span></span><br><span class="line"><span class="keyword">const</span> item3 = <span class="title function_">consumeFirst</span>(<span class="keyword">new</span> <span class="title class_">Queue1</span>&lt;<span class="built_in">number</span>&gt;()) <span class="comment">// number | undefined</span></span><br><span class="line"><span class="keyword">const</span> item4 = <span class="title function_">consumeFirst</span>(<span class="keyword">new</span> <span class="title class_">Queue1</span>()) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ../src/0.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时使用多个泛型</span></span><br><span class="line"><span class="keyword">function</span> tuple&lt;<span class="title class_">Ele</span>, K&gt;(<span class="attr">arg1</span>: <span class="title class_">Ele</span>[], <span class="attr">arg2</span>: K): [<span class="title class_">Ele</span>[], K] &#123;</span><br><span class="line">    <span class="keyword">return</span> [arg1, arg2]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> output3 = <span class="title function_">tuple</span>([<span class="string">&quot;test&quot;</span>], <span class="number">1</span>)   <span class="comment">// [string[], number]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给定默认值</span></span><br><span class="line"><span class="keyword">type</span> O&lt;<span class="title class_">One</span> = <span class="built_in">string</span>, <span class="title class_">Second</span> = <span class="built_in">number</span>&gt; = &#123; [<span class="attr">index</span>: <span class="built_in">string</span>]: [<span class="title class_">One</span>, <span class="title class_">Second</span>]&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T3</span> = O  <span class="comment">// &#123; [index: string]: [string, number] &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><p>使用 <code>extends</code> 关键词对泛型进行约束</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/0.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> F1 &#123;</span><br><span class="line">    <span class="comment">// 一个对外的函数，期望传入 &#123; [index: string]: any &#125; 这样一个对象</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">identityObj</span>(<span class="params">arg: &#123; [index: <span class="built_in">string</span>]: <span class="built_in">any</span> &#125;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arg</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> r1 = <span class="title function_">identityObj</span>(&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;) <span class="comment">// &#123; [index: string]: any &#125;，无法获得更精确的类型</span></span><br><span class="line">    <span class="keyword">const</span> r2 = <span class="title function_">identityObj</span>(<span class="number">1</span>)   <span class="comment">// 类型“1”的参数不能赋给类型“&#123; [index: string]: any; &#125;”的参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> F2 &#123;</span><br><span class="line">    <span class="comment">// 对参数进行约束</span></span><br><span class="line">    <span class="keyword">function</span> identityObj&lt;T <span class="keyword">extends</span> &#123; [<span class="attr">index</span>: <span class="built_in">string</span>]: <span class="built_in">any</span> &#125;&gt;(<span class="attr">arg</span>: T) &#123;</span><br><span class="line">        <span class="keyword">return</span> arg</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> r1 = <span class="title function_">identityObj</span>(&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;) <span class="comment">// &#123; a: number &#125;</span></span><br><span class="line">    <span class="keyword">const</span> r2 = <span class="title function_">identityObj</span>(<span class="number">1</span>)   <span class="comment">// 类型“1”的参数不能赋给类型“&#123; [index: string]: any; &#125;”的参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型参数相互约束</span></span><br><span class="line"><span class="keyword">function</span> getProperty&lt;T, K <span class="keyword">extends</span> keyof T&gt;(<span class="attr">obj</span>: T, <span class="attr">key</span>: K) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>, <span class="attr">d</span>: <span class="number">4</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getProperty</span>(x, <span class="string">&quot;a&quot;</span>) <span class="comment">// okay</span></span><br><span class="line"><span class="title function_">getProperty</span>(x, <span class="string">&quot;m&quot;</span>) <span class="comment">// error: Argument of type &#x27;m&#x27; isn&#x27;t assignable to &#x27;a&#x27; | &#x27;b&#x27; | &#x27;c&#x27; | &#x27;d&#x27;.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> S3 &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Controller</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Stationary</span>&gt; &#123;</span><br><span class="line">        <span class="attr">status</span>: T | <span class="literal">undefined</span></span><br><span class="line">        <span class="title function_">onData</span>(<span class="params">s: T</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">status</span> = s</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">abstract</span> <span class="title function_">work</span>(): <span class="built_in">void</span></span><br><span class="line"></span><br><span class="line">        <span class="title function_">getPropertyD</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">status</span>) <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">status</span>.<span class="property">d</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">getPropertyDV2</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">status</span>) <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">status</span>.<span class="property">d</span> <span class="keyword">as</span> T[<span class="string">&quot;d&quot;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ControllerV1</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Controller</span>&lt;<span class="title class_">StationaryV1</span>&gt; &#123;</span><br><span class="line">        <span class="title function_">work</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> t = <span class="variable language_">this</span>.<span class="property">status</span> <span class="comment">// StationaryV1 | undefined, ok</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> v1 = <span class="keyword">new</span> <span class="title class_">ControllerV1</span>()</span><br><span class="line">    <span class="keyword">const</span> d1 = v1.<span class="title function_">getPropertyD</span>()  <span class="comment">// &#123; e: string; &#125; | &#123; f: number; &#125; | undefined</span></span><br><span class="line">    <span class="keyword">const</span> d2 = v1.<span class="title function_">getPropertyDV2</span>()  <span class="comment">// &#123; e: string; &#125; | undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h2><h3 id="extends-条件类型"><a href="#extends-条件类型" class="headerlink" title="extends 条件类型"></a>extends 条件类型</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// T extends U ? X : Y</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TypeName</span>&lt;T&gt; =</span><br><span class="line">    T <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="string">&quot;string&quot;</span> :</span><br><span class="line">    T <span class="keyword">extends</span> <span class="built_in">number</span> ? <span class="string">&quot;number&quot;</span> :</span><br><span class="line">    T <span class="keyword">extends</span> <span class="built_in">boolean</span> ? <span class="string">&quot;boolean&quot;</span> :</span><br><span class="line">    T <span class="keyword">extends</span> <span class="literal">undefined</span> ? <span class="string">&quot;undefined&quot;</span> :</span><br><span class="line">    T <span class="keyword">extends</span> <span class="title class_">Function</span> ? <span class="string">&quot;function&quot;</span> : <span class="string">&quot;other&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> test1 = <span class="title class_">TypeName</span>&lt;<span class="built_in">string</span>&gt;  <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="keyword">type</span> test2 = <span class="title class_">TypeName</span>&lt;<span class="string">&quot;a&quot;</span>&gt;  <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="keyword">type</span> test3 = <span class="title class_">TypeName</span>&lt;<span class="literal">true</span>&gt;  <span class="comment">// &quot;boolean&quot;</span></span><br><span class="line"><span class="keyword">type</span> test4 = <span class="title class_">TypeName</span>&lt;<span class="function">() =&gt;</span> <span class="built_in">void</span>&gt;  <span class="comment">// &quot;function&quot;</span></span><br><span class="line"><span class="keyword">type</span> test5 = <span class="title class_">TypeName</span>&lt;<span class="built_in">string</span>[]&gt;  <span class="comment">// &quot;other&quot;</span></span><br><span class="line"><span class="keyword">type</span> test6 = <span class="title class_">TypeName</span>&lt;<span class="built_in">string</span> | (<span class="function">() =&gt;</span> <span class="built_in">void</span>)&gt;  <span class="comment">// &quot;string&quot; | &quot;function&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="infer-条件推断"><a href="#infer-条件推断" class="headerlink" title="infer 条件推断"></a>infer 条件推断</h3><p>用于和 <code>extends</code> 配合从一种类型中提取需要的类型</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">StrIndexObjInfer</span>&lt;O&gt; =</span><br><span class="line">    O <span class="keyword">extends</span> &#123; [<span class="attr">index</span>: <span class="built_in">string</span>]: infer A &#125;</span><br><span class="line">    ? A             <span class="comment">// If true</span></span><br><span class="line">    : <span class="built_in">never</span>         <span class="comment">// If false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> test1  = <span class="title class_">StrIndexObjInfer</span>&lt;&#123; <span class="attr">a</span>: <span class="built_in">string</span> &#125;&gt; <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> test2  = <span class="title class_">StrIndexObjInfer</span>&lt;<span class="built_in">string</span>&gt;        <span class="comment">// never</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FunctionInfer</span>&lt;F&gt; =</span><br><span class="line">    F <span class="keyword">extends</span> (...<span class="attr">args</span>: infer A) =&gt; infer R</span><br><span class="line">    ? [A, R]        <span class="comment">// If true</span></span><br><span class="line">    : <span class="built_in">never</span>         <span class="comment">// If false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn01</span>  = (<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">any</span></span>) =&gt; <span class="literal">true</span></span><br><span class="line"><span class="keyword">type</span> test3 = <span class="title class_">FunctionInfer</span>&lt;<span class="keyword">typeof</span> fn01&gt; <span class="comment">// [[a: number, b: any], boolean]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ArrayInfer</span>&lt;T&gt; =</span><br><span class="line">    T <span class="keyword">extends</span> (infer U)[]</span><br><span class="line">    ? U</span><br><span class="line">    : <span class="built_in">never</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">0</span>, <span class="string">&#x27;data&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;data&#x27;</span>]</span><br><span class="line"><span class="keyword">type</span> test4 = <span class="title class_">ArrayInfer</span>&lt;<span class="keyword">typeof</span> array&gt; <span class="comment">// string | number</span></span><br></pre></td></tr></table></figure>

<h3 id="官方预设的一些工具类型"><a href="#官方预设的一些工具类型" class="headerlink" title="官方预设的一些工具类型"></a>官方预设的一些工具类型</h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svdXRpbGl0eS10eXBlcy5odG1s">typescript: utility-types<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 所有属性变为可选</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Partial</span>&lt;T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> keyof T]?: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">P1</span> = <span class="title class_">Partial</span>&lt;&#123; <span class="attr">a</span>: <span class="built_in">string</span> &#125;&gt; <span class="comment">// &#123; a?: string | undefined &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可用于 client 中 filter 类型的参数</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Book</span> = &#123; <span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">price</span>: <span class="built_in">number</span>, <span class="attr">pages</span>: <span class="built_in">number</span> &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getBooks</span>(<span class="params">params: Partial&lt;Book&gt;</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有属性变为必选</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Required</span>&lt;T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> keyof T]?: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">R1</span> = <span class="title class_">Required</span>&lt;&#123; a?: <span class="built_in">string</span> &#125;&gt; <span class="comment">// &#123; a: string &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有属性变为只读</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Readonly</span>&lt;T&gt; = &#123;</span><br><span class="line">    <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">R2</span> = <span class="title class_">Readonly</span>&lt;&#123; <span class="attr">a</span>: <span class="built_in">string</span> &#125;&gt; <span class="comment">// &#123; readonly a: string &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可用于输出一个只读对象</span></span><br><span class="line"><span class="keyword">function</span> getReadonlyObj&lt;T <span class="keyword">extends</span> &#123;[<span class="attr">index</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>&#125;&gt;(<span class="attr">params</span>: T) &#123;</span><br><span class="line">    <span class="comment">// do something to params</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> params <span class="keyword">as</span> <span class="title class_">Readonly</span>&lt;T&gt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> readonlyObj1 = <span class="title function_">getReadonlyObj</span>(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="string">&quot;yes&quot;</span> &#125; &#125;)</span><br><span class="line">readonlyObj1.<span class="property">a</span> = <span class="number">2</span>  <span class="comment">// Cannot assign to &#x27;a&#x27; because it is a read-only property.</span></span><br><span class="line">readonlyObj1.<span class="property">b</span>.<span class="property">c</span> = <span class="string">&quot;no&quot;</span> <span class="comment">// 对深层次属性无效</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readonlyObj2 = <span class="title function_">getReadonlyObj</span>([<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line">readonlyObj2[<span class="number">0</span>] = <span class="number">3</span> <span class="comment">// 类型“readonly (number | number[])[]”中的索引签名仅允许读取</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取 T 中部分的属性</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Pick</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> K]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">P2</span> = <span class="title class_">Pick</span>&lt;&#123; <span class="attr">a</span>: <span class="built_in">string</span>, <span class="attr">b</span>: <span class="built_in">number</span>, <span class="attr">c</span>: <span class="literal">null</span> &#125;, <span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span>&gt; <span class="comment">// &#123; a: string; b: number &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 去掉 T 中部分的属性</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Omit</span>&lt;T, K <span class="keyword">extends</span> keyof <span class="built_in">any</span>&gt; = <span class="title class_">Pick</span>&lt;T, <span class="title class_">Exclude</span>&lt;keyof T, K&gt;&gt;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">O1</span> = <span class="title class_">Omit</span>&lt;&#123; <span class="attr">a</span>: <span class="built_in">string</span>, <span class="attr">b</span>: <span class="built_in">number</span>, <span class="attr">c</span>: <span class="literal">null</span> &#125;, <span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span>&gt; <span class="comment">// &#123; c: null &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 T 中不属于 U 的类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Exclude</span>&lt;T, U&gt; = T <span class="keyword">extends</span> U ? <span class="built_in">never</span> : T</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">E1</span> = <span class="title class_">Exclude</span>&lt;<span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span> | <span class="string">&quot;c&quot;</span> | <span class="string">&quot;d&quot;</span>, <span class="string">&quot;a&quot;</span> | <span class="string">&quot;c&quot;</span> | <span class="string">&quot;f&quot;</span>&gt;;  <span class="comment">// &quot;b&quot; | &quot;d&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 T、U 公有的类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Extract</span>&lt;T, U&gt; = T <span class="keyword">extends</span> U ? T : <span class="built_in">never</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">E2</span> = <span class="title class_">Extract</span>&lt;<span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span> | <span class="string">&quot;c&quot;</span> | <span class="string">&quot;d&quot;</span>, <span class="string">&quot;a&quot;</span> | <span class="string">&quot;c&quot;</span> | <span class="string">&quot;f&quot;</span>&gt;;  <span class="comment">// &quot;a&quot; | &quot;c&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 去掉 null, undefined</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NonNullable</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="literal">null</span> | <span class="literal">undefined</span> ? <span class="built_in">never</span> : T</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">N1</span> = <span class="title class_">NonNullable</span>&lt;<span class="built_in">string</span> | <span class="built_in">number</span> | <span class="literal">undefined</span>&gt;;  <span class="comment">// string | number</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取函数参数类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Parameters</span>&lt;T <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (...<span class="attr">args</span>: infer P) =&gt; <span class="built_in">any</span> ? P : <span class="built_in">never</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">P3</span> = <span class="title class_">Parameters</span>&lt;<span class="function">(<span class="params">a: <span class="built_in">string</span>, b?: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>&gt; <span class="comment">//  [a: string, b?: number | undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">identity</span>(<span class="params">arg: <span class="built_in">string</span></span>): <span class="built_in">string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">identity</span>(<span class="params">arg: <span class="built_in">number</span></span>): <span class="built_in">number</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">identity</span>(<span class="params">arg: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">P4</span> = <span class="title class_">Parameters</span>&lt;<span class="keyword">typeof</span> identity&gt; <span class="comment">// [arg: number]，对签名重载的函数取最后一条</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取函数返回值类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ReturnType</span>&lt;T <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>) =&gt; infer R ? R : <span class="built_in">any</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">R3</span> = <span class="title class_">ReturnType</span>&lt;<span class="function">() =&gt;</span> <span class="built_in">string</span>&gt; <span class="comment">// string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 Promise 类型返回值去掉 Promise</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ReturnTypeV2</span>&lt;T <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>) =&gt; infer R ? R <span class="keyword">extends</span> <span class="title class_">Promise</span>&lt;infer S&gt; ? S : R : <span class="built_in">any</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">R4</span> = <span class="title class_">ReturnTypeV2</span>&lt;<span class="function">() =&gt;</span> <span class="title class_">Promise</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="comment">// string</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程</category>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>（译文）NodeJS 事件循环（一）- 事件循环机制概述</title>
    <url>/2020/12/20/event-loop-and-the-big-picture-nodejs-event-loop-part-1/</url>
    <content><![CDATA[<p>原文地址：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmluc2lkZXJhdHRhY2submV0L2V2ZW50LWxvb3AtYW5kLXRoZS1iaWctcGljdHVyZS1ub2RlanMtZXZlbnQtbG9vcC1wYXJ0LTEtMWNiNjdhMTgyODEw">Event Loop and the Big Picture — NodeJS Event Loop Part 1, Deepal Jayasekara, Apr 23, 2017<i class="fa fa-external-link-alt"></i></span></p>
<p>处理 I&#x2F;O 的不同方式使得 Node.js 区别于其他的编程平台。我们常常听到别人在介绍 Node.js 时说 “一个基于 google v8 JavaScript 引擎的非阻塞，事件驱动的平台”。这句话究竟意味着什么？“非阻塞”和“事件驱动”是什么意思？所有这些问题的答案涉及到 NodeJs 的核心，事件循环。在这个系列中，我会阐释什么是事件循环，它是如何工作的，它如何影响我们的应用，如何有效使用等等。在这篇文章中，我将讲解 NodeJs 如何工作，如何访问 I&#x2F;O，如何跨平台工作等等。</p>
<span id="more"></span>

<h2 id="反应器模式-（Reactor-Pattern）"><a href="#反应器模式-（Reactor-Pattern）" class="headerlink" title="反应器模式 （Reactor Pattern）"></a>反应器模式 （Reactor Pattern）</h2><p>NodeJS 在一个事件驱动的模型中工作，其中涉及到一个事件<strong>多路分用器（Event Demultiplexer）</strong> 和一个<strong>事件队列（Event Queue）</strong>。所有的 I&#x2F;O 请求最终会生成一个或成功或失败或其他触发器的<strong>事件（Event）</strong>。事件通过下面的算法进行处理。</p>
<ol>
<li>事件多路分用器接受 I&#x2F;O 请求并将这些请求委托给对应的硬件。</li>
<li>当 I&#x2F;O 请求被处理时（例如：一个文件里的数据可以被读取，一个 socket 的数据可以被读取等），事件多路分用器将该特定动作的回调处理器添加到一个待处理的队列中。这些回调被称为事件，事件添加的队列被称为<strong>事件队列</strong>。</li>
<li>当事件队列中存在待处理的事件时，它们会按入队的顺序依次执行，直到队列为空。</li>
<li>如果事件队列中没有待处理的事件或者事件多路分用器没有挂起的请求，程序会结束。否则，又会从第一步重新开始。</li>
</ol>
<p>协调整个机制的程序被称为<strong>事件循环（Event Loop）</strong>。</p>
<p><img data-src="/2020/12/20/event-loop-and-the-big-picture-nodejs-event-loop-part-1/1.Event-Loop.jpeg" alt="Event Loop"></p>
<p>事件循环是单线程和半无限的循环。因为它在没有更多的工作要做时会在一些点退出，这就是为什么称为半无限循环的原因。在开发者的视角，这就是程序退出的地方。</p>
<blockquote>
<p>注意: 不要将事件循环和 NodeJs 的 EventEmitter 混淆。EventEmitter 跟事件循环相比完全是另一个不同的概念。</p>
</blockquote>
<p>上面的图解是 NodeJs 如何工作的一个高层次概述，展示了反应器模式的主要组件。但是实际情况比这个要复杂的多，到底有多复杂？</p>
<blockquote>
<p>事件多路分发器不是在所有系统平台上处理所有 I&#x2F;O 的单一组件。<br>事件队列并不像图中展示的那样是一个所有事件都入队和出队的单独队列。并且 I&#x2F;O 不是唯一入队的事件类型。</p>
</blockquote>
<p>因此，让我们更深入些。</p>
<h2 id="事件多路分发器-Event-Demultiplexer"><a href="#事件多路分发器-Event-Demultiplexer" class="headerlink" title="事件多路分发器 (Event Demultiplexer)"></a>事件多路分发器 (Event Demultiplexer)</h2><p>事件多路分发器不是一个在真实世界中存在的组件，而是反应器模式中的一个抽象概念。现实世界中，事件多路分发器在不同的系统中有不同的实现。比如在 Linux 中的 <strong>epoll</strong> ，BSD（MacOS）系统中的 <strong>kqueue</strong> ，Solaris 中的 <strong>event ports</strong> ，windows 中的 <strong>IOCP（Input Output Completion Port）</strong>等等。NodeJS 利用这些实现提供的底层，非阻塞异步的硬件 I&#x2F;O 能力。</p>
<h3 id="文件-I-x2F-O-的复杂性"><a href="#文件-I-x2F-O-的复杂性" class="headerlink" title="文件 I&#x2F;O 的复杂性"></a>文件 I&#x2F;O 的复杂性</h3><p>但令人烦心的是，并不是所有类型的 I&#x2F;O 都可以使用这些实现执行。即使在同一操作系统平台，对不同类型的 I&#x2F;O 的支持也十分复杂。典型的例子，网络 I&#x2F;O 使用 epoll，kqueu，events ports 和 IOCP 可以以非阻塞的方式执行。但是文件 I&#x2F;O 则不一定。特定的系统，如 Linux 不支持完全的异步访问文件系统。并且在 MacOS 系统上 kquue 的文件系统事件通知和信号有很多限制(<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmxpYnRvcnJlbnQub3JnLzIwMTIvMTAvYXN5bmNocm9ub3VzLWRpc2staW8v">更多相关介绍<i class="fa fa-external-link-alt"></i></span>)。情况复杂到以至于几乎不可能同时处理所有文件系统的复杂度来提供完整的异步功能。</p>
<h3 id="DNS-的复杂性"><a href="#DNS-的复杂性" class="headerlink" title="DNS 的复杂性"></a>DNS 的复杂性</h3><p>与文件 I&#x2F;O 相似，Node API 提供的 DNS 函数也有一定的<span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2FwaS9kbnMuaHRtbCNkbnNfaW1wbGVtZW50YXRpb25fY29uc2lkZXJhdGlvbnM=">复杂性<i class="fa fa-external-link-alt"></i></span>。因为 NodeJS DNS 函数如 dns.lookup，会访问系统配置文件如 nsswitch.conf，resolve.conf 和 &#x2F;etc&#x2F;hosts，之前提到的文件系统的复杂性也适用于 dns.lookup 函数。</p>
<h3 id="解决办法？"><a href="#解决办法？" class="headerlink" title="解决办法？"></a>解决办法？</h3><p>因此，引入了一个<strong>线程池</strong>来提供不能被硬件异步 I&#x2F;O 工具（epoll&#x2F;kqueue&#x2F;event ports&#x2F;IOCP）直接支持的 I&#x2F;O 功能。现在我们知道并不是所有的 I&#x2F;O 功能发生在线程池。NodeJS 尽最大的努力使用非阻塞和异步硬件 I&#x2F;O 来处理大部分的 I&#x2F;O 工作，但是对于那些阻塞或者处理起来很复杂的 I&#x2F;O，则使用线程池。</p>
<blockquote>
<p>但是 I&#x2F;O 不是线程池唯一处理的任务。Node.js 的部分 <code>crypto</code> 功能如 <code>crypto.pbkdf2</code>，异步版本的 <code>crypto.randomBytes</code>，<code>crypto.randomFill</code>，异步版本的 <code>zlib</code> 也运行在 libuv 的线程池。因为它们属于 CPU 密集型工作，在线程池工作能够避免阻塞事件循环。</p>
</blockquote>
<h2 id="把他们拼在一起"><a href="#把他们拼在一起" class="headerlink" title="把他们拼在一起"></a>把他们拼在一起</h2><p>正如我们看到的，实际世界中，在所有不同操作系统平台支持所有不同类型的 I&#x2F;O（文件 I&#x2F;O，网络 I&#x2F;O，DNS 等）非常困难。一部分 I&#x2F;O 可以使用原生硬件实现执行，同时保留完整的异步，另外一部分类型的 I&#x2F;O 则需要在线程池中执行以保证异步特性。</p>
<blockquote>
<p>Node 开发者中，一个普遍的误解是 Node 在线程池中处理所有的 I&#x2F;O。</p>
</blockquote>
<p>为了管理整个过程同时支持跨平台的 I&#x2F;O，应该有一个抽象层封装了平台间和平台内的复杂度，并且为 Node 提供上层通用 API。</p>
<p>那么是谁呢？女士们，先生们，有请 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpYnV2L2xpYnV2">libuv<i class="fa fa-external-link-alt"></i></span></p>
<p><img data-src="/2020/12/20/event-loop-and-the-big-picture-nodejs-event-loop-part-1/2.Official-libuv-logo.png" alt="Official-libuv-logo.png"></p>
<p><span class="exturl" data-url="aHR0cDovL2RvY3MubGlidXYub3JnL2VuL3YxLngvZGVzaWduLmh0bWw=">official libuv docs<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<p>libuv is cross-platform support library which was originally written for NodeJS. It’s designed around the event-driven asynchronous I&#x2F;O model.</p>
</blockquote>
<blockquote>
<p>The library provides much more than a simple abstraction over different I&#x2F;O polling mechanisms: ‘handles’ and ‘streams’ provide a high level abstraction for sockets and other entities; cross-platform file I&#x2F;O and threading functionality is also provided, amongst other things.</p>
</blockquote>
<p>让我们看下 libuv 的组成。下面的图表来自于官方文档，描述了暴露出的通用 API 处理了哪些不同类型的 I&#x2F;O。</p>
<p><img data-src="/2020/12/20/event-loop-and-the-big-picture-nodejs-event-loop-part-1/3.libuv-architecture.jpeg" alt="libuv-architecture"></p>
<p>现在我们知道<strong>事件多路分发器</strong>，不是一个原子的实体，而是一个被 Libuv 抽象出的处理 I&#x2F;O 过程的 APIs 集合，暴露给 NodeJS 的上层使用。libuv 除了提供事件多路分发器给 Node，它还为 NodeJS 提供了完整的事件循环功能，包含事件队列机制。</p>
<p>现在让我们看下<strong>事件队列</strong>。</p>
<h2 id="事件队列"><a href="#事件队列" class="headerlink" title="事件队列"></a>事件队列</h2><p>事件队列按理说是一个所有事件入队，然后事件循环按顺序处理，直到队列为空的数据结构。但是在 Node 中实际发生的和反应器模式描述的完全不同。所以差异在哪？</p>
<blockquote>
<p>NodeJS 中不止一个队列，不同类型的事件会在它们自己的队列中入队。<br>在处理完一个阶段后，移向下一个阶段之前，事件循环将会处理两个中间队列，直到两个中间队列为空。</p>
</blockquote>
<p>那么总共有多少个队列呢？中间队列又是什么？</p>
<p>有 4 个主要类型的队列，被原生的 libuv 事件循环处理。</p>
<ul>
<li><strong>Expired timers and intervals Queue</strong>— 使用 setTimeout 添加的过期计时器的回调或者使用 setInterval 添加的间隔函数。</li>
<li><strong>IO Events Queue</strong>— 完成的 I&#x2F;O 事件</li>
<li><strong>Immediate queue</strong>- 使用 setImmediate 函数添加的回调</li>
<li><strong>Close Handlers Queue</strong>- 任何一个 close 事件处理器。</li>
</ul>
<blockquote>
<p>注意，尽管我在这里为方便说 “队列”，但它们中的一些实际上有不同类型的数据结构（timers 被存储在最小堆里）</p>
</blockquote>
<p>除了四个主要的队列，这里另外有两个我之前提到的 “中间队列”，它们被 Node 处理。这些队列不是 libuv 的一部分，而是 NodeJS 的一部分。它们分别是：</p>
<ul>
<li><strong>Next Ticks Queue</strong> - 使用 process.nextTick() 函数添加的回调</li>
<li><strong>other Microtasks Queue</strong> - 包含其他微任务如成功的 Promise 回调</li>
</ul>
<h2 id="它是如何工作的？"><a href="#它是如何工作的？" class="headerlink" title="它是如何工作的？"></a>它是如何工作的？</h2><p>正如你在下面图表中所见，Node 开始事件循环先检查 timers 队列中是否有任何过期的 timers，然后在每个步骤中处理每个队列，同时保持对所有待处理对象的引用计数器。处理完 close handlers 队列，如果在所有的队列中没有要处理的项，而且也没有挂起的操作，那么循环将会退出。在事件循环中每个队列的处理过程可以看做事件循环的一个阶段。</p>
<p><img data-src="/2020/12/20/event-loop-and-the-big-picture-nodejs-event-loop-part-1/4.all-Q.png"></p>
<p>有趣的是被描绘成红色的中间队列，只要一个阶段结束，事件循环将会检查这两个中间阶段是否有要处理的项。如果有，事件循环会立马开始处理它们直到两个队列为空。一旦为空，事件循环就移到下一个阶段。</p>
<blockquote>
<p>E.g, 事件循环当前处理有着 5 个事件处理器的 immediate queue。同时，两个处理器回调被添加到 next tick queue。一旦事件处理器完成 immediate queue 中的 5 个事件处理器，事件循环将会在移到 close handlers 队列之前检测到 next tick queue 里面有两个要处理的项。然后事件处理器会处理完 next tick queue 里面的处理器。然后移到 close handlers 队列。</p>
</blockquote>
<h2 id="Next-tick-queue-vs-Other-Microtasks"><a href="#Next-tick-queue-vs-Other-Microtasks" class="headerlink" title="Next tick queue vs Other Microtasks"></a>Next tick queue vs Other Microtasks</h2><p>next tick queue 比 other micotasks 有着更高的优先级。当在一个阶段的结尾时 libuv 传递控制权给 Node 的高层，这时这两个队列都在事件循环的两个阶段之间被处理。你应该注意到我用暗红色来表示 next tick queue，这意味着在开始处理 promise 的微队列之前，next tick queue 是空的。</p>
<blockquote>
<p>next tick queue 的优先级比 promise 的高仅仅适合于 V8 提供的原生 JS 提供的 promise。如果你使用一个 q 库或者 bluebird, 你将会观察到一个不同的结果，因为它们早于原生的 promise，有不同的语义。q 和 bluebird 处理 promise 也有不同的方式，后面的文章我会解释。</p>
</blockquote>
<p>这些所谓的中间队列引入了一个新的问题，IO 饿死。广泛的使用 <code>process.nextTick</code> 填充 next tick queue 将会强迫事件循环处理 next tick queue 而不前进。这将会导致 IO 饿死，因为 next tick queue 未被清空前事件循环不能继续。</p>
<blockquote>
<p>为了防止这种清空，这里有一个 next tick queue 的最大限制，可以使用 <code>procsess.maxTickDepth</code> 参数设置，但是已经从 NodeJS v0.12 移除了。具体查看<span class="exturl" data-url="aHR0cHM6Ly9zdHJvbmdsb29wLmNvbS9zdHJvbmdibG9nL25vZGUtanMtdjAtMTItYXBpcy1icmVha2luZy8jcHJvY2Vzc19tYXh0aWNrZGVwdGhfcmVtb3ZlZA==">原因<i class="fa fa-external-link-alt"></i></span>。 </p>
</blockquote>
<p>我将会在之后的文章中用示例深入讨论这些队列。</p>
<p>最后，你知道了什么是事件循环，如何实现的和 Node 处理异步 I&#x2F;O。让我们看下 Libuv 在 NodeJS 架构中的位置。</p>
<p><img data-src="/2020/12/20/event-loop-and-the-big-picture-nodejs-event-loop-part-1/5.NodeJS-Architecture.png" alt="NodeJS-Architecture"></p>
]]></content>
      <categories>
        <category>编程</category>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>事件循环</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 泛型进阶篇</title>
    <url>/2020/12/04/TypeScript-%E6%B3%9B%E5%9E%8B%E8%BF%9B%E9%98%B6%E7%AF%87/</url>
    <content><![CDATA[<p>介绍 TypeScript 泛型的进阶应用，核心是递归类型</p>
<p>Github Repo 地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lseXlkeS90eXBlc2NyaXB0LWdlbmVyaWM=">https://github.com/ilyydy/typescript-generic<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>

<h2 id="从一个问题出发"><a href="#从一个问题出发" class="headerlink" title="从一个问题出发"></a>从一个问题出发</h2><p>获取一个深层嵌套对象的底层属性值</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Obj</span> = &#123;</span><br><span class="line">    <span class="attr">a1</span>: &#123;</span><br><span class="line">            <span class="attr">b1</span>: <span class="built_in">boolean</span></span><br><span class="line">            <span class="attr">b2</span>: &#123;</span><br><span class="line">                <span class="attr">c1</span>: <span class="built_in">string</span></span><br><span class="line">                <span class="attr">c2</span>: [<span class="number">1</span>, <span class="number">2</span>] | <span class="literal">undefined</span></span><br><span class="line">            &#125; | <span class="literal">null</span></span><br><span class="line">        &#125; | <span class="string">&quot;init&quot;</span></span><br><span class="line">    <span class="attr">a2</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// src/1.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params">param: Obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        param.<span class="property">a1</span> !== <span class="string">&quot;init&quot;</span> &amp;&amp;</span><br><span class="line">        param.<span class="property">a1</span>.<span class="property">b2</span> !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        param.<span class="property">a1</span>.<span class="property">b2</span>.<span class="property">c2</span> !== <span class="literal">undefined</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">const</span> v1 = param.<span class="property">a1</span>.<span class="property">b2</span>.<span class="property">c2</span>[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> v1 <span class="comment">// 返回值类型是 1, 但必须层层判断类型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用  lodash 的 get</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params">param: Obj</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> v2 = _.<span class="title function_">get</span>(param, [<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;b2&quot;</span>, <span class="string">&quot;c2&quot;</span>, <span class="string">&quot;0&quot;</span>]) <span class="comment">// 路径不能提示，返回值类型是 any</span></span><br><span class="line">    <span class="keyword">return</span> v2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="从1到复杂"><a href="#从1到复杂" class="headerlink" title="从1到复杂"></a>从1到复杂</h2><h3 id="获取第一层属性值"><a href="#获取第一层属性值" class="headerlink" title="获取第一层属性值"></a>获取第一层属性值</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">obj1</span>: <span class="title class_">Obj</span> = &#123;</span><br><span class="line">    <span class="attr">a1</span>: &#123;</span><br><span class="line">        <span class="attr">b1</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">b2</span>: &#123;</span><br><span class="line">            <span class="attr">c1</span>: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">            <span class="attr">c2</span>: [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">a2</span>: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">StrIndexObj</span> = &#123; [<span class="attr">index</span>: <span class="built_in">string</span>]: <span class="built_in">any</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/2.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> getProperty&lt;T, <span class="variable constant_">K1</span> <span class="keyword">extends</span> keyof T&gt;(<span class="attr">param</span>: T, <span class="attr">k1</span>: <span class="variable constant_">K1</span>): T[<span class="variable constant_">K1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 参数 param 输入 obj1 后，参数 k1 提示 &quot;a1&quot; | &quot;a2&quot;</span></span><br><span class="line"><span class="comment">    参数 k1 输入 &quot;a1&quot; 后， test3 类型为</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    b1: boolean;</span></span><br><span class="line"><span class="comment">    b2: &#123; c1: string; c2: [1, 2] | undefined &#125; | null;</span></span><br><span class="line"><span class="comment">&#125; | &quot;init&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test3 = <span class="title function_">getProperty</span>(obj1, <span class="string">&quot;a1&quot;</span>) <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<h3 id="在此基础上尝试扩展"><a href="#在此基础上尝试扩展" class="headerlink" title="在此基础上尝试扩展"></a>在此基础上尝试扩展</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/2.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> getProperty&lt;T, <span class="variable constant_">K1</span> <span class="keyword">extends</span> keyof T, <span class="variable constant_">K2</span> <span class="keyword">extends</span> keyof T[<span class="variable constant_">K1</span>]&gt;(</span><br><span class="line">    <span class="attr">param</span>: T,</span><br><span class="line">    <span class="attr">k1</span>: <span class="variable constant_">K1</span>,</span><br><span class="line">    <span class="attr">k2</span>: <span class="variable constant_">K2</span></span><br><span class="line">): T[<span class="variable constant_">K1</span>][<span class="variable constant_">K2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 参数 param 输入 obj 后， 参数 k1 提示 &quot;a1&quot; | &quot;a2&quot;</span></span><br><span class="line"><span class="comment">    参数 k1 输入 &quot;a1&quot; 后， 参数 k2 提示 never</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> test4 = <span class="title function_">getProperty</span>(obj1, <span class="string">&quot;a1&quot;</span>, <span class="string">&quot;b2&quot;</span>) <span class="comment">// error, 类型“&quot;b2&quot;”的参数不能赋给类型“never”的参数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">A1</span> = <span class="title class_">Obj</span>[<span class="string">&quot;a1&quot;</span>]  <span class="comment">// 可能为 &quot;init&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">KeyofA1</span>_1 = keyof <span class="variable constant_">A1</span>  <span class="comment">// 不能对 &quot;init&quot; 使用 keyof，所以 KeyofA1_1 为 never</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">KeyofA1</span>_2 = keyof <span class="title class_">Extract</span>&lt;<span class="variable constant_">A1</span>, <span class="title class_">StrIndexObj</span>&gt;  <span class="comment">// &quot;b1&quot; | &quot;b2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> getProperty&lt;T, <span class="variable constant_">K1</span> <span class="keyword">extends</span> keyof T, <span class="variable constant_">K2</span> <span class="keyword">extends</span> keyof <span class="title class_">Extract</span>&lt;T[<span class="variable constant_">K1</span>], <span class="title class_">StrIndexObj</span>&gt;&gt;(</span><br><span class="line">    <span class="attr">param</span>: T,</span><br><span class="line">    <span class="attr">k1</span>: <span class="variable constant_">K1</span>,</span><br><span class="line">    <span class="attr">k2</span>: <span class="variable constant_">K2</span></span><br><span class="line">): <span class="title class_">Extract</span>&lt;T[<span class="variable constant_">K1</span>], <span class="title class_">StrIndexObj</span>&gt;[<span class="variable constant_">K2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">/* test5 类型为 &#123;</span></span><br><span class="line"><span class="comment">c1: string;</span></span><br><span class="line"><span class="comment">c2: [1, 2] | undefined;</span></span><br><span class="line"><span class="comment">&#125; | null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> test5 = <span class="title function_">getProperty</span>(obj1, <span class="string">&quot;a1&quot;</span>, <span class="string">&quot;b2&quot;</span>) <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第三层</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> getProperty&lt;</span><br><span class="line">    T,</span><br><span class="line">    <span class="variable constant_">K1</span> <span class="keyword">extends</span> keyof T,</span><br><span class="line">    <span class="variable constant_">K2</span> <span class="keyword">extends</span> keyof <span class="title class_">Extract</span>&lt;T[<span class="variable constant_">K1</span>], <span class="title class_">StrIndexObj</span>&gt;,</span><br><span class="line">    <span class="variable constant_">K3</span> <span class="keyword">extends</span> keyof <span class="title class_">Extract</span>&lt;<span class="title class_">Extract</span>&lt;T[<span class="variable constant_">K1</span>], <span class="title class_">StrIndexObj</span>&gt;[<span class="variable constant_">K2</span>], <span class="title class_">StrIndexObj</span>&gt;</span><br><span class="line">&gt;(<span class="attr">param</span>: T, <span class="attr">k1</span>: <span class="variable constant_">K1</span>, <span class="attr">k2</span>: <span class="variable constant_">K2</span>, <span class="attr">k3</span>: <span class="variable constant_">K3</span>): <span class="title class_">Extract</span>&lt;<span class="title class_">Extract</span>&lt;T[<span class="variable constant_">K1</span>], <span class="title class_">StrIndexObj</span>&gt;[<span class="variable constant_">K2</span>], <span class="title class_">StrIndexObj</span>&gt;[<span class="variable constant_">K3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test6 = <span class="title function_">getProperty</span>(obj1, <span class="string">&quot;a1&quot;</span>, <span class="string">&quot;b2&quot;</span>, <span class="string">&quot;c2&quot;</span>)  <span class="comment">//  [1, 2] | undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="增加默认返回值"><a href="#增加默认返回值" class="headerlink" title="增加默认返回值"></a>增加默认返回值</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/3.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似 lodash，将所有 key 的数组作为第二个参数，默认值作为第三个参数</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> getProperty&lt;T, <span class="variable constant_">K1</span> <span class="keyword">extends</span> keyof T&gt;(<span class="attr">param</span>: T, [k1]: [<span class="variable constant_">K1</span>]): T[<span class="variable constant_">K1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> getProperty&lt;</span><br><span class="line">    T,</span><br><span class="line">    <span class="variable constant_">K1</span> <span class="keyword">extends</span> keyof T,</span><br><span class="line">    <span class="variable constant_">K2</span> <span class="keyword">extends</span> keyof <span class="title class_">Extract</span>&lt;T[<span class="variable constant_">K1</span>], <span class="title class_">StrIndexObj</span>&gt;,</span><br><span class="line">    D</span><br><span class="line">&gt;(<span class="attr">param</span>: T, [k1, k2]: [<span class="variable constant_">K1</span>, <span class="variable constant_">K2</span>], <span class="attr">defaultValue</span>: D): <span class="title class_">Extract</span>&lt;T[<span class="variable constant_">K1</span>],  <span class="title class_">StrIndexObj</span>&gt;[<span class="variable constant_">K2</span>] | D</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> getProperty&lt;</span><br><span class="line">    T,</span><br><span class="line">    <span class="variable constant_">K1</span> <span class="keyword">extends</span> keyof T,</span><br><span class="line">    <span class="variable constant_">K2</span> <span class="keyword">extends</span> keyof <span class="title class_">Extract</span>&lt;T[<span class="variable constant_">K1</span>], <span class="title class_">StrIndexObj</span>&gt;,</span><br><span class="line">    <span class="variable constant_">K3</span> <span class="keyword">extends</span> keyof <span class="title class_">Extract</span>&lt;<span class="title class_">Extract</span>&lt;T[<span class="variable constant_">K1</span>], <span class="title class_">StrIndexObj</span>&gt;[<span class="variable constant_">K2</span>], <span class="title class_">StrIndexObj</span>&gt;,</span><br><span class="line">    D</span><br><span class="line">&gt;(<span class="attr">param</span>: T, [k1, k2, k3]: [<span class="variable constant_">K1</span>, <span class="variable constant_">K2</span>, <span class="variable constant_">K3</span>], <span class="attr">defaultValue</span>: D):  <span class="title class_">Extract</span>&lt;<span class="title class_">Extract</span>&lt;T[<span class="variable constant_">K1</span>],  <span class="title class_">StrIndexObj</span>&gt;[<span class="variable constant_">K2</span>], <span class="title class_">StrIndexObj</span>&gt;[<span class="variable constant_">K3</span>] | D</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test7 = <span class="title function_">getProperty</span>(obj1, [<span class="string">&quot;a1&quot;</span>])  <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">const</span> test8 = <span class="title function_">getProperty</span>(obj1, [<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;b2&quot;</span>], <span class="literal">undefined</span>)  <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">const</span> test9 = <span class="title function_">getProperty</span>(obj1, [<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;b2&quot;</span>, <span class="string">&quot;c2&quot;</span>], <span class="literal">undefined</span>)  <span class="comment">// 可以正确使用，但编辑器无法参数提示</span></span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不将所有 key 作为数组</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> getProperty&lt;T, <span class="variable constant_">K1</span> <span class="keyword">extends</span> keyof T&gt;(<span class="attr">param</span>: T, <span class="attr">k1</span>: <span class="variable constant_">K1</span>): T[<span class="variable constant_">K1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> getProperty&lt;</span><br><span class="line">    T,</span><br><span class="line">    <span class="variable constant_">K1</span> <span class="keyword">extends</span> keyof T,</span><br><span class="line">    <span class="variable constant_">K2</span> <span class="keyword">extends</span> keyof <span class="title class_">Extract</span>&lt;T[<span class="variable constant_">K1</span>], <span class="title class_">StrIndexObj</span>&gt;,</span><br><span class="line">    D,</span><br><span class="line">&gt;(<span class="attr">param</span>: T, <span class="attr">k1</span>: <span class="variable constant_">K1</span>, <span class="attr">k2</span>: <span class="variable constant_">K2</span>, <span class="attr">defaultValue</span>: D): <span class="title class_">Extract</span>&lt;T[<span class="variable constant_">K1</span>], <span class="title class_">StrIndexObj</span>&gt;[<span class="variable constant_">K2</span>] | D</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> getProperty&lt;</span><br><span class="line">    T,</span><br><span class="line">    <span class="variable constant_">K1</span> <span class="keyword">extends</span> keyof T,</span><br><span class="line">    <span class="variable constant_">K2</span> <span class="keyword">extends</span> keyof <span class="title class_">Extract</span>&lt;T[<span class="variable constant_">K1</span>], <span class="title class_">StrIndexObj</span>&gt;,</span><br><span class="line">    <span class="variable constant_">K3</span> <span class="keyword">extends</span> keyof  <span class="title class_">Extract</span>&lt;<span class="title class_">Extract</span>&lt;T[<span class="variable constant_">K1</span>], <span class="title class_">StrIndexObj</span>&gt;[<span class="variable constant_">K2</span>], <span class="title class_">StrIndexObj</span>&gt;,</span><br><span class="line">    D,</span><br><span class="line">&gt;(<span class="attr">param</span>: T, <span class="attr">k1</span>: <span class="variable constant_">K1</span>, <span class="attr">k2</span>: <span class="variable constant_">K2</span>, <span class="attr">k3</span>: <span class="variable constant_">K3</span>, <span class="attr">defaultValue</span>: D):  <span class="title class_">Extract</span>&lt;<span class="title class_">Extract</span>&lt;T[<span class="variable constant_">K1</span>],  <span class="title class_">StrIndexObj</span>&gt;[<span class="variable constant_">K2</span>], <span class="title class_">StrIndexObj</span>&gt;[<span class="variable constant_">K3</span>] | D</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test10 = <span class="title function_">getProperty</span>(obj1, <span class="string">&quot;a1&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> test11 = <span class="title function_">getProperty</span>(obj1, <span class="string">&quot;a1&quot;</span>, <span class="string">&quot;b2&quot;</span>, <span class="string">&quot;fault&quot;</span>)  <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">const</span> test12 = <span class="title function_">getProperty</span>(obj1, <span class="string">&quot;a1&quot;</span>, <span class="string">&quot;b2&quot;</span>, <span class="string">&quot;c2&quot;</span>, <span class="string">&quot;fault&quot;</span>)  <span class="comment">// 可以正确使用，但需要先输入 defaultValue 编辑器才能提示第 3 个 key</span></span><br></pre></td></tr></table></figure>

<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>如何简化 getProperty 的参数类型和返回值类型</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/4.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">GetKey</span>&lt;T&gt; = keyof <span class="title class_">Extract</span>&lt;T, <span class="title class_">StrIndexObj</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// but:</span></span><br><span class="line"><span class="keyword">type</span> test0 = keyof <span class="title class_">StrIndexObj</span> <span class="comment">// string | number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// so:</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">GetKey</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="title class_">StrIndexObj</span> ? <span class="title class_">Extract</span>&lt;keyof T, <span class="built_in">string</span>&gt; : <span class="built_in">never</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> test1 = <span class="title class_">GetKey</span>&lt;<span class="title class_">Obj</span>&gt; <span class="comment">// &quot;a1&quot; | &quot;a2&quot;</span></span><br><span class="line"><span class="keyword">type</span> test2 = <span class="title class_">GetKey</span>&lt;<span class="built_in">string</span>&gt; <span class="comment">// never</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">GetValue</span>&lt;T, <span class="title class_">KList</span> <span class="keyword">extends</span> <span class="built_in">string</span>[]&gt; = ?</span><br></pre></td></tr></table></figure>

<h3 id="递归类型"><a href="#递归类型" class="headerlink" title="递归类型"></a>递归类型</h3><p>思路： 递归使用 GetValue，每次消耗 KList 第一个元素，直到为空</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Head</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [] ? <span class="built_in">never</span> : T[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">type</span> test3 = <span class="title class_">Head</span>&lt;[<span class="string">&quot;1&quot;</span>, <span class="number">2</span>]&gt; <span class="comment">// &quot;1&quot;</span></span><br><span class="line"><span class="keyword">type</span> test4 = <span class="title class_">Head</span>&lt;<span class="built_in">string</span>[]&gt; <span class="comment">// string</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Tail</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = (<span class="function">(<span class="params">...t: T</span>) =&gt;</span> <span class="built_in">any</span>) <span class="keyword">extends</span> (<span class="function">(<span class="params">_: <span class="built_in">any</span>, ...tail: infer TT</span>) =&gt;</span> <span class="built_in">any</span>) ? <span class="variable constant_">TT</span> : []</span><br><span class="line"><span class="keyword">type</span> test5 = <span class="title class_">Tail</span>&lt;[<span class="string">&quot;1&quot;</span>, <span class="number">2</span>]&gt; <span class="comment">// [2]</span></span><br><span class="line"><span class="keyword">type</span> test6 = <span class="title class_">Tail</span>&lt;<span class="built_in">string</span>[]&gt; <span class="comment">// string[]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Length</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T[<span class="string">&quot;length&quot;</span>]</span><br><span class="line"><span class="keyword">type</span> test7 = <span class="title class_">Length</span>&lt;[<span class="number">1</span>, <span class="number">2</span>]&gt; <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">type</span> test8 = <span class="title class_">Length</span>&lt;<span class="built_in">string</span>[]&gt;  <span class="comment">// number</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Last</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T[<span class="title class_">Length</span>&lt;<span class="title class_">Tail</span>&lt;T&gt;&gt;]</span><br><span class="line"><span class="keyword">type</span> test9 = <span class="title class_">Last</span>&lt;[<span class="string">&quot;1&quot;</span>, <span class="number">2</span>]&gt;</span><br><span class="line"><span class="keyword">type</span> test10 = <span class="title class_">Last</span>&lt;<span class="built_in">string</span>[]&gt; <span class="comment">// string</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">GetValue</span>&lt;T <span class="keyword">extends</span> <span class="title class_">StrIndexObj</span>, <span class="title class_">KList</span> <span class="keyword">extends</span> <span class="built_in">string</span>[]&gt; = &#123;</span><br><span class="line">    <span class="number">0</span>: T</span><br><span class="line">    <span class="number">1</span>: <span class="title class_">GetValue</span>&lt;<span class="title class_">Extract</span>&lt;T, <span class="title class_">StrIndexObj</span>&gt;[<span class="title class_">Head</span>&lt;<span class="title class_">KList</span>&gt;], <span class="title class_">Tail</span>&lt;<span class="title class_">KList</span>&gt;&gt;</span><br><span class="line">&#125; [ <span class="title class_">KList</span> <span class="keyword">extends</span> [] ? <span class="number">0</span> : <span class="number">1</span> ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> test11 = <span class="title class_">GetValue</span>&lt;<span class="title class_">Obj</span>, [<span class="string">&quot;a1&quot;</span>]&gt; <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">type</span> test12 = <span class="title class_">GetValue</span>&lt;<span class="title class_">Obj</span>, [<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;b2&quot;</span>]&gt; <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">type</span> test13 = <span class="title class_">GetValue</span>&lt;<span class="title class_">Obj</span>, [<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;b2&quot;</span>, <span class="string">&quot;c2&quot;</span>]&gt; <span class="comment">// ok</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="使用-GetKey-GetValue"><a href="#使用-GetKey-GetValue" class="headerlink" title="使用 GetKey GetValue"></a>使用 <code>GetKey</code> <code>GetValue</code></h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> getProperty&lt;T, <span class="variable constant_">K1</span> <span class="keyword">extends</span> <span class="title class_">GetKey</span>&lt;T&gt;&gt;(<span class="attr">param</span>: T, <span class="attr">k1</span>: <span class="variable constant_">K1</span>): <span class="title class_">GetValue</span>&lt;T, [<span class="variable constant_">K1</span>]&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> t1 = <span class="title function_">getProperty</span>(obj1, <span class="string">&quot;a1&quot;</span>)  <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> getProperty&lt;</span><br><span class="line">    T,</span><br><span class="line">    <span class="variable constant_">K1</span> <span class="keyword">extends</span> <span class="title class_">GetKey</span>&lt;T&gt;,</span><br><span class="line">    <span class="variable constant_">K2</span> <span class="keyword">extends</span> <span class="title class_">GetKey</span>&lt;<span class="title class_">GetValue</span>&lt;T, [<span class="variable constant_">K1</span>]&gt;&gt;,</span><br><span class="line">    D,</span><br><span class="line">&gt;(<span class="attr">param</span>: T, <span class="attr">k1</span>: <span class="variable constant_">K1</span>, <span class="attr">k2</span>: <span class="variable constant_">K2</span>, <span class="attr">defaultValue</span>: D): <span class="title class_">GetValue</span>&lt;T, [<span class="variable constant_">K1</span>, <span class="variable constant_">K2</span>]&gt; | D</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> t2 = <span class="title function_">getProperty</span>(obj1, <span class="string">&quot;a1&quot;</span>, <span class="string">&quot;b2&quot;</span>, <span class="string">&quot;fault&quot;</span>)  <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> getProperty&lt;</span><br><span class="line">    T,</span><br><span class="line">    <span class="variable constant_">K1</span> <span class="keyword">extends</span> <span class="title class_">GetKey</span>&lt;T&gt;,</span><br><span class="line">    <span class="variable constant_">K2</span> <span class="keyword">extends</span> <span class="title class_">GetKey</span>&lt;<span class="title class_">GetValue</span>&lt;T, [<span class="variable constant_">K1</span>]&gt;&gt;,</span><br><span class="line">    <span class="variable constant_">K3</span> <span class="keyword">extends</span> <span class="title class_">GetKey</span>&lt;<span class="title class_">GetValue</span>&lt;T, [<span class="variable constant_">K1</span>, <span class="variable constant_">K2</span>]&gt;&gt;,</span><br><span class="line">    D,</span><br><span class="line">&gt;(<span class="attr">param</span>: T, <span class="attr">k1</span>: <span class="variable constant_">K1</span>, <span class="attr">k2</span>: <span class="variable constant_">K2</span>, <span class="attr">k3</span>: <span class="variable constant_">K3</span>, <span class="attr">defaultValue</span>: D): <span class="title class_">GetValue</span>&lt;T, [<span class="variable constant_">K1</span>, <span class="variable constant_">K2</span>, <span class="variable constant_">K3</span>]&gt; | D</span><br><span class="line"><span class="keyword">const</span> t3 = <span class="title function_">getProperty</span>(obj1, <span class="string">&quot;a1&quot;</span>, <span class="string">&quot;b2&quot;</span>, <span class="string">&quot;c2&quot;</span>, <span class="string">&quot;fault&quot;</span>) <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="typescript-3-7"><a href="#typescript-3-7" class="headerlink" title="typescript 3.7"></a>typescript 3.7</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Optional Chaining 特性, `?.` operator for optional property accesses. 只能用于 null, undefined 两种情况</span></span><br><span class="line"><span class="comment">// src/5.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p1</span>: &#123; <span class="attr">a</span>: <span class="literal">undefined</span> | <span class="literal">null</span> | &#123; <span class="attr">b</span>: <span class="number">1</span> &#125; &#125; = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">1</span>&#125; &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">a</span>?.<span class="property">b</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p2</span>: &#123; <span class="attr">a</span>: <span class="literal">undefined</span> | &#123; <span class="attr">b</span>: <span class="number">1</span> &#125; &#125; = &#123; <span class="attr">a</span>: <span class="literal">null</span> &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2.<span class="property">a</span>?.<span class="property">b</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="更多奇淫技巧"><a href="#更多奇淫技巧" class="headerlink" title="更多奇淫技巧"></a>更多奇淫技巧</h3><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0QtWS1Jbm5vdmF0aW9ucy90eXBlcy11dGlscw==">types-utils<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L3B1bGwvMjQ4OTcjaXNzdWVjb21tZW50LTQwMTQxODI1NA==">typeScript 的核心开发者 Anders Hejlsberg 对此的看法<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<p>It’s clever, but it definitely pushes things well beyond their  intended use. While it may work for small examples, it will scale horribly. Resolving those deeply recursive types consumes a lot of time and resources and might in the future run afoul of the recursion governors we have in the checker.</p>
<p>Don’t do it!</p>
</blockquote>
]]></content>
      <categories>
        <category>编程</category>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>（译文）NodeJS 事件循环（五）- 最佳实践</title>
    <url>/2021/02/28/event-loop-best-practices-nodejs-event-loop-part-5/</url>
    <content><![CDATA[<p>原文地址：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmluc2lkZXJhdHRhY2submV0L2V2ZW50LWxvb3AtYmVzdC1wcmFjdGljZXMtbm9kZWpzLWV2ZW50LWxvb3AtcGFydC01LWUyOWIyYjUwYmZlMg==">Event Loop Best Practices — NodeJS Event Loop Part 5, Deepal Jayasekara, Dec 29, 2017<i class="fa fa-external-link-alt"></i></span></p>
<p>事件循环这一系列文章到此已经讨论了事件循环和它不同的阶段，包括 <code>setImmediate</code>， <code>nextTick</code> 计时器以及上篇文章 <a href="/2020/12/26/handling-io-nodejs-event-loop-part-4/" title="（译文）NodeJS 事件循环（四）- Handling IO">（译文）NodeJS 事件循环（四）- Handling IO</a> 的 I&#x2F;O。我相信你现在已经很好地理解 NodeJS 的事件循环。因此现在来谈谈最佳实践，怎样才能在开发 Node 应用时获得最好的结果和性能表现。</p>
<p>大多数人因为不了解事件循环、错误处理和异步的相关概念（我在<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmluc2lkZXJhdHRhY2submV0L3lvdS1yZWFsbHktaGF0ZS1ub2RlLTU4YjFmZjcyMjAyZA==">这篇博客<i class="fa fa-external-link-alt"></i></span>中进行了详细讨论）而搞砸了他们最初的 NodeJS 应用。因为你已经理解了事件循环，我相信你或许已经知道而且能够理解我下面将要提到的最佳实践。现在让我们一起看看吧。</p>
<span id="more"></span>

<h2 id="在重复调用代码块中避免使用同步-I-x2F-O"><a href="#在重复调用代码块中避免使用同步-I-x2F-O" class="headerlink" title="在重复调用代码块中避免使用同步 I&#x2F;O"></a>在重复调用代码块中避免使用同步 I&#x2F;O</h2><p>在重复调用代码块如循环、经常被调用的函数中避免使用同步 I&#x2F;O（<code>fs.readFileSync</code>, <code>fs.renameSync</code> 等）。这会极大地削弱你应用的性能表现，因为每次执行同步 I&#x2F;O，事件循环都会被阻塞直到 I&#x2F;O 完成。使用这些同步方法最安全的之一途径是在应用启动时读取配置文件。</p>
<h2 id="函数要么完全异步，要么完全同步"><a href="#函数要么完全异步，要么完全同步" class="headerlink" title="函数要么完全异步，要么完全同步"></a>函数要么完全异步，要么完全同步</h2><p>你的应用由许许多多函数组成。在 NodeJS 应用中，有两种类型的函数：</p>
<ol>
<li>同步函数 —— 大多数情况下使用 <code>return</code> 关键词返回输出（<code>Math</code> 函数，<code>fs.readFileSync</code> 等），或者使用 CPS（Continuation Passing Style 后续传递风格）来返回结果或执行操作（Array 原型方法如 <code>map</code> <code>filter</code> <code>reduce</code>）。</li>
<li>异步函数 —— 用回调函数或 promise 来延迟返回结果（<code>fs.readFile</code> <code>dns.resolve</code>等）</li>
</ol>
<p>对函数的经验法则：</p>
<ul>
<li>完全同步 —— 所有输入和条件都是同步</li>
<li>完全异步 ——— 所有输入和条件都是异步</li>
</ul>
<p>如果你的函数是以上两种混合体，或者对不同的输入和条件有不同的表现，这可能<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLml6cy5tZS8yMDEzLzA4L2Rlc2lnbmluZy1hcGlzLWZvci1hc3luY2hyb255">导致非预期的输出结果<i class="fa fa-external-link-alt"></i></span>。让我们看一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cache = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">readFile</span>(<span class="params">fileName, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cache[fileName]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">callback</span>(<span class="literal">null</span>, cache[fileName])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fs.<span class="title function_">readFile</span>(fileName, <span class="function">(<span class="params">err, fileContent</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="title function_">callback</span>(err);</span><br><span class="line">        </span><br><span class="line">        cache[fileName] = fileContent;</span><br><span class="line">        <span class="title function_">callback</span>(<span class="literal">null</span>, fileContent);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">letsRead</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">readFile</span>(<span class="string">&#x27;myfile.txt&#x27;</span>, <span class="function">(<span class="params">err, result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// error handler redacted</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;file read complete&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;file read initiated&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你的应用中在运行 <code>letsRead</code> 函数结束后再次运行，你会得到以下输出：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">file <span class="built_in">read</span> initiated</span><br><span class="line">file <span class="built_in">read</span> complete</span><br><span class="line"></span><br><span class="line">file <span class="built_in">read</span> complete</span><br><span class="line">file <span class="built_in">read</span> initiated</span><br></pre></td></tr></table></figure>

<p>这中间发生了什么？</p>
<p>你第一次运行 <code>letsRead</code> 时，<code>myfile.txt</code> 在 cache 中不存在，因此异步的 <code>fs.readFile</code> 将会被调用访问文件系统。这种情况下 <code>readFile</code> 异步执行，先打印 <code>file read initiated</code>。</p>
<p>而第二次时，<code>myfile.txt</code> 已经在第一次时被读取存到 cache 中，因此不需要再访问文件系统，回调函数被立即同步执行。这种情况下，<code>readFile</code> 函数同步执行，<code>file read complete</code> 在 <code>file read initiated</code> 之前被打印。</p>
<p>当你的应用变得复杂，这种同步、异步混合的函数会导致许多难以定位和修复的问题。因此，强烈推荐遵循以上的<strong>要么同步要么异步</strong>的法则。</p>
<p>现在，如何修复上面的 <code>readFile</code> 函数呢，我们有两种方法：</p>
<p>方法 1：使用 <code>fs.readFileSync</code> 让 <code>readFile</code> 变成完全的同步函数<br>方法 2：异步调用回调函数让 <code>readFile</code> 变成完全的异步函数</p>
<p>如上面所说，我们知道在重复代码块中异步调用函数是更好的。因此，我们不应该使用方法 1，它会带来显著的性能损失。那么我们如何实现方法 2，异步调用回调函数呢？很简单，使用 <code>process.nextTick</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cache = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">readFile</span>(<span class="params">fileName, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cache[fileName]) &#123;</span><br><span class="line">        <span class="keyword">return</span> process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> <span class="title function_">callback</span>(<span class="literal">null</span>, cache[fileName]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fs.<span class="title function_">readFile</span>(fileName, <span class="function">(<span class="params">err, fileContent</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="title function_">callback</span>(err);</span><br><span class="line">        </span><br><span class="line">        cache[fileName] = fileContent;</span><br><span class="line">        <span class="title function_">callback</span>(<span class="literal">null</span>, fileContent);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>process.nextTick</code> 会延迟回调函数的执行。现在，如果你运行 <code>letsRead</code> 连续运行函数两次，你会得到以下结果：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">file <span class="built_in">read</span> initiated</span><br><span class="line">file <span class="built_in">read</span> complete</span><br><span class="line"></span><br><span class="line">file <span class="built_in">read</span> initiated</span><br><span class="line">file <span class="built_in">read</span> complete</span><br></pre></td></tr></table></figure>

<p>你也可以用 <code>setImmediate</code> 来达到相同的效果，但我更倾向用 <code>process.nextTick</code>，因为 nextTick 队列比 immediates 队列更频繁被处理。</p>
<h2 id="太多-nextTicks"><a href="#太多-nextTicks" class="headerlink" title="太多 nextTicks"></a>太多 nextTicks</h2><p>虽然 <code>process.nextTick</code> 在很多情况下有用，但递归调用它会导致 I&#x2F;O 饿死。</p>
<p>0.10 及更早版本的 NodeJS 提供了 <code>process.maxTickDepth</code> 来设置 nextTick 回调最大深度，但是这个参数在 0.12 版本的 NodeJS 中随 <code>setImmediate</code> 的引入而被移除。因此现在没有一种方法能限制 nextTicks 饿死 I&#x2F;O。</p>
<h2 id="dns-lookup-vs-dns-resolve"><a href="#dns-lookup-vs-dns-resolve" class="headerlink" title="dns.lookup() vs dns.resolve*()"></a>dns.lookup() vs dns.resolve*()</h2><p>如果你看了 NodeJS 的 dns 模块文档，你会发现 dns 模块中有两种解析域名为 IP 地址的途径。一种是 <code>dns.lookup</code>，另一种是 <code>dns.resolve4</code> <code>dns.resolve6</code> 等。虽然这两种途径看起来效果一样，但它们底层有着显著的区别。</p>
<p><code>dns.lookup</code> 和 <code>ping</code> 解析域名的原理类似。它调用操作系统的网络 API <code>getaddrinfo</code>。不幸的是，这个调用不是异步的。因此，为了模仿异步行为，调用在 libuv 的线程池中调用 <code>uv_getaddrinfo</code> 方法。这会和线程池中其他任务争抢资源，导致应用的性能损失。重要的是，libuv 线程池默认只有 4  个线程。因此，4 个并行的 <code>dns.lookup</code> 调用会完全占用线程池，无法处理其他请求（文件 I&#x2F;O，一些加解密方法，可能更多的 dns 查询）。</p>
<p>相反，<code>dns.resolve()</code> 和其他的 <code>dns.resolve*()</code> 已另一种方式运行。以下是官方文档中对 <code>dns.resolve*</code> 的描述：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">These <span class="built_in">functions</span> are implemented quite differently than dns.lookup(). They <span class="keyword">do</span> not use getaddrinfo(3) and they always perform a DNS query on the network. This network communication is always <span class="keyword">done</span> asynchronously, and does not use libuv<span class="string">&#x27;s threadpool.</span></span><br></pre></td></tr></table></figure>

<p>NodeJS 使用一个流行库 <a href="https://github.com/c-ares/c-ares"><code>c-ares</code></a> 来提供 DNS 解析能力。这个库不依赖 libuv 的线程池，完全依赖网络。</p>
<p><code>dns.resolve()</code> 不会是 libuv 超负荷，所以使用 <code>dns.resolve()</code> 而不是 <code>dns.lookup</code> 是更好的选择，除非需要考虑 <code>getaddrinfo</code> 会用到的配置文件 <code>/etc/nsswitch.conf</code> <code>/etc/hosts</code>。</p>
<p>但还有一个更大的问题！</p>
<p>假如你有使用 NodeJS 发起一个访问 <code>www.example.com</code> 的 HTTP 请求。首先，它会解析 <code>www.example.com</code> 为 IP 地址。然后它使用解析得到的 IP 地址异步建立 TCP 连接。所以，发送 HTTP 请求是一个两步的过程。</p>
<p>现在，Node <code>http</code> <code>https</code> 模块都使用 <code>dns.lookup</code> 来解析域名为 IP 地址。当 DNS 服务异常或者因为高网络&#x2F;dns 延迟，多个 http 请求会导致线程池对其他请求不可用。已经有一个关于 <code>http</code> <code>https</code> 此问题的 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JlcXVlc3QvcmVxdWVzdC9pc3N1ZXMvMjQ5MQ==">issue<i class="fa fa-external-link-alt"></i></span> ，但到我写这篇文章为止，为了和操作系统的行为保持一致，一切还是原样。更糟的是，许多 http client 库如 <code>request</code> 也使用了 <code>http</code> <code>https</code>，受这个 issue 的影响。</p>
<p>如果你注意到你的应用在文件 I&#x2F;O，加解密或其他线程池相关的任务有巨大的性能下降，你可以做这些来提高应用的性能：</p>
<ul>
<li>你可以通过设置环境变量 <code>UV_THREADPOOL_SIZE</code> 提高线程池的容量最大到 128 个线程</li>
<li>使用 <code>dns.resolve*()</code> 解决域名或直接使用 IP。以下是一份和 <code>request</code> 相同的样例代码</li>
</ul>
<p><em>请注意以下代码没有经过优化，仅仅是一个如何实现的例子。另外对一个强健的实现还有很多其他因素需要考虑。而且，以下代码只能用于 Node v8.0.0 及以后，因为 <code>lookup</code> 选项在更早的 <code>tls.connect</code> 实现中不存在</em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dns = <span class="built_in">require</span>(<span class="string">&#x27;dns&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> https = <span class="built_in">require</span>(<span class="string">&#x27;https&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> tls = <span class="built_in">require</span>(<span class="string">&#x27;tls&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">&#x27;net&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">&#x27;request&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> httpAgent = <span class="keyword">new</span> http.<span class="title class_">Agent</span>();</span><br><span class="line"><span class="keyword">const</span> httpsAgent = <span class="keyword">new</span> https.<span class="title class_">Agent</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createConnection</span> = (<span class="params">&#123; isHttps = <span class="literal">false</span> &#125; = &#123;&#125;</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> connect = isHttps ? tls.<span class="property">connect</span> : net.<span class="property">connect</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">args, cb</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">connect</span>(&#123;</span><br><span class="line">            port : args.<span class="property">port</span>,</span><br><span class="line">            host : args.<span class="property">host</span>,</span><br><span class="line">            lookup : <span class="keyword">function</span>(<span class="params">hostname, args, cb</span>) &#123;</span><br><span class="line">                dns.<span class="title function_">resolve</span>(hostname, <span class="keyword">function</span>(<span class="params">err, ips</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (err) &#123; <span class="keyword">return</span> <span class="title function_">cb</span>(err); &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="title function_">cb</span>(<span class="literal">null</span>, ips[<span class="number">0</span>], <span class="number">4</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, cb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">httpAgent.<span class="property">createConnection</span> = <span class="title function_">createConnection</span>();</span><br><span class="line">httpsAgent.<span class="property">createConnection</span> = <span class="title function_">createConnection</span>(&#123;<span class="attr">isHttps</span>: <span class="literal">true</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getRequest</span>(<span class="params">reqUrl</span>) &#123;</span><br><span class="line">    <span class="title function_">request</span>(&#123;</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">        <span class="attr">url</span>: reqUrl,</span><br><span class="line">        <span class="attr">agent</span>: httpsAgent</span><br><span class="line">    &#125;, <span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">body</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getRequest</span>(<span class="string">&#x27;https://example.com&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="线程池的注意点"><a href="#线程池的注意点" class="headerlink" title="线程池的注意点"></a>线程池的注意点</h2><p>正如我们在这一系列所见，libuv 线程池除了文件 I&#x2F;O 还用于很多其他地方，它可能是应用的瓶颈。如果你认为你的应用在文件 I&#x2F;O 或加解密操作比平常更慢，考虑通过环境变量 <code>UV_THREADPOOL_SIZE</code> 增加线程池的规模。</p>
<h2 id="事件循环监控"><a href="#事件循环监控" class="headerlink" title="事件循环监控"></a>事件循环监控</h2><p>监控事件循环延迟在避免应用混乱非常重要。这也可以用来报警，执行强制重启和扩容服务。</p>
<p>最简单的识别事件循环延迟的方法是通过检查一个计时器执行回调所需额外花费的时间。简单来说，假如我们设置一个 500 ms 后执行的计时器，如果它花费 550 ms 执行回调，我们可以推测事件循环的延迟大概是 50 ms。额外花费的 50 ms 用于执行事件循环的其他阶段。你也不需要自己写上述脚本，相反可以使用 <a href="https://www.npmjs.com/package/loopbench"><code>loopbench</code></a> 来监控事件循环。让我们看看如何使用：</p>
<p>安装这个库之后，你可以在你的应用中用以下代码使用 <code>loopbench</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">LoopBench</span> = <span class="built_in">require</span>(<span class="string">&#x27;loopbench&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> loopBench = <span class="title class_">LoopBench</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`loop delay: <span class="subst">$&#123;loopBench.delay&#125;</span>`</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`loop delay limit: <span class="subst">$&#123;loopBench.limit&#125;</span>`</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`is loop overloaded: <span class="subst">$&#123;loopBench.overlimit&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>

<p>通过这段代码，你可以暴露一个健康检查点，用于暴露这些值你可以和其他的监控&#x2F;报警工具进行集成。</p>
<p>上述例子中 API 的一个响应示例类似以下结构:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;message&quot;</span>: <span class="string">&quot;application is running&quot;</span>,</span><br><span class="line">  <span class="string">&quot;data&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;loop_delay&quot;</span>: <span class="string">&quot;1.2913 ms&quot;</span>,</span><br><span class="line">    <span class="string">&quot;loop_delay_limit&quot;</span>: <span class="string">&quot;42 ms&quot;</span>,</span><br><span class="line">    <span class="string">&quot;is_loop_overloaded&quot;</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过这种实现，当循环已经超负荷，为了防止加剧超负荷，你可以在健康检查 API 返回 503 服务不可用的响应。如果你需要高可用性，这也可以帮助负载均衡来代理请求到应用的其他实例。</p>
]]></content>
      <categories>
        <category>编程</category>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>事件循环</tag>
      </tags>
  </entry>
  <entry>
    <title>（译文）NodeJS 事件循环（四）- Handling IO</title>
    <url>/2020/12/26/handling-io-nodejs-event-loop-part-4/</url>
    <content><![CDATA[<p>原文地址：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmluc2lkZXJhdHRhY2submV0L2hhbmRsaW5nLWlvLW5vZGVqcy1ldmVudC1sb29wLXBhcnQtNC00MTgwNjJmOTE3ZDE=">Handling IO — NodeJS Event Loop Part 4, Deepal Jayasekara, Nov 26, 2017<i class="fa fa-external-link-alt"></i></span></p>
<p>系列上篇文章 <a href="/2020/12/20/promises-next-ticks-and-immediates-nodejs-event-loop-part-3/" title="（译文）NodeJS 事件循环（三）- Promises, Next-Ticks, and Immediates">（译文）NodeJS 事件循环（三）- Promises, Next-Ticks, and Immediates</a></p>
<p>本篇文章中，我将详细讨论 NodeJS 如何处理 I&#x2F;O，深入探讨事件循环的实现以及 I&#x2F;O 如何与其他异步操作组合在一起。如果你尚未阅读本系列前面 3 篇文章，我建议你先看看它们，我在它们中探讨了 NodeJS 事件循环的其他许多概念。</p>
<span id="more"></span>

<h2 id="异步-I-x2F-O"><a href="#异步-I-x2F-O" class="headerlink" title="异步 I&#x2F;O"></a>异步 I&#x2F;O</h2><p>NodeJS 中我们反复谈到异步 I&#x2F;O。正如本系列第一篇文章提到的，I&#x2F;O 并不注定是同步的。</p>
<p><img data-src="/2020/12/26/handling-io-nodejs-event-loop-part-4/1.jpg"></p>
<p>所有操作系统实现中，它们都提供异步 I&#x2F;O 的事件通知接口（linux epoll, macOS kqueue，solaris event ports，windows IOCP 等）。NodeJS 利用这些系统级别的事件通知系统来提供非阻塞、异步 I&#x2F;O。</p>
<p>如下图所见，NodeJS 是一系列工具的集合，它们聚合成高性能的 NodeJS 运行时。这些工具包括：</p>
<ul>
<li>Chrome v8 引擎 —— 高效执行 JavaScript</li>
<li>Libuv —— 异步 I&#x2F;O 事件循环</li>
<li>c-ares —— DNS 操作</li>
<li>其他插件如 http-parser，crypto 和 zlib</li>
</ul>
<p><img data-src="/2020/12/26/handling-io-nodejs-event-loop-part-4/2.NodeJS-Architecture.png" alt="Node JS High-Level Architecture"></p>
<p>这篇文章中我会讲解 Libuv 和它如何向 Node 提供异步 I&#x2F;O。让我们再回顾事件循环图示。</p>
<p><img data-src="/2020/12/26/handling-io-nodejs-event-loop-part-4/3.all-Q.png" alt="The Event Loop in a nutshell"></p>
<p>我们已经学到的事件循环知识有：</p>
<ul>
<li>事件循环从处理所有过时的定时器开始</li>
<li>接着处理所有挂起的 I&#x2F;O 操作，可能会等待挂起的 I&#x2F;O 变为完成</li>
<li>然后处理 setImmediate 回调</li>
<li>最后处理 I&#x2F;O close 的处理器</li>
<li>上述每个阶段间，libuv 会把阶段的执行结果通知 Node 架构的更上层部分，也就是 JavaScript。每次通知发生时，<code>process.nextTick</code> 回调和其他微任务回调就会被执行。</li>
</ul>
<p>现在，让我们理解 NodeJS 在事件循环中如何处理 I&#x2F;O。</p>
<blockquote>
<p>什么是 I&#x2F;O？</p>
<p>一般地，涉及到除 CPU 以外的外部设备的工作都可被称为 I&#x2F;O。最常见的抽象 I&#x2F;O 类型有文件操作和 TCP&#x2F;UDP 网络操作。</p>
</blockquote>
<h2 id="Libuv-和-NodeJS-I-x2F-O"><a href="#Libuv-和-NodeJS-I-x2F-O" class="headerlink" title="Libuv 和 NodeJS I&#x2F;O"></a>Libuv 和 NodeJS I&#x2F;O</h2><p>JavaScript 本身没有能力实现异步 I&#x2F;O 操作。NodeJS 开发过程中，libuv 最初是为了给 Node 提供异步 I&#x2F;O。libuv 现在已经是一个独立的库，可独立被使用。Libuv 在 NodeJS 架构中的角色是抽象和屏蔽内部 I&#x2F;O 复杂度，给上层的 Node 提供通用的接口，让 Node 具有跨平台的异步 I&#x2F;O 能力。</p>
<blockquote>
<p>警示！</p>
<p>如果你对事件循环没有基本的概念，我建议你先阅读本系列之前的文章。为了集中讲述 I&#x2F;O，我会省略一些细节。</p>
<p>我会使用 libuv 一些源码片段。为了更简易，我只会举 Unix 平台的样例，Windows 平台虽然会有些不同，但相差应该不会太大。</p>
<p>我假定你对 C 有一定了解。不用太熟练，但需要能理解基本的流程。</p>
</blockquote>
<p>如 NodeJS 架构图所示，libuv 在架构中处于较底层的位置。现在，让我们看看 NodeJS 上层和 libuv 事件循环各阶段之间的关系。</p>
<p><img data-src="/2020/12/26/handling-io-nodejs-event-loop-part-4/4.Event-loop-and-JavaScript.jpg" alt="Event loop and JavaScript"></p>
<p>图 “The Event Loop in a nutshell” 中事件循环存在 4 个可区分的阶段。但在 libuv 中其实存在 7 个可区分的阶段：</p>
<ol>
<li>Timers —— 执行过期的 <code>setTimeout</code> 和 <code>setInterval</code> 回调</li>
<li>Pending I&#x2F;O callbacks —— 执行挂起的已完成或发生错误 I&#x2F;O 回调</li>
<li>Idle handlers —— libuv 内部事务处理</li>
<li>Prepare Handlers —— poll I&#x2F;O 前的准备工作</li>
<li>I&#x2F;O Poll —— 可能等待任意的 I&#x2F;O 变为完成</li>
<li>Check handlers —— poll I&#x2F;O 后的事后工作，一般是 <code>setImmediate</code> 回调</li>
<li>Close handlers —— 所有关闭 I&#x2F;O 的处理器</li>
</ol>
<p>如果你还记得第一篇文章，你可能会疑惑：</p>
<ol>
<li>Check handlers 是什么？它在事件循环图中不存在。</li>
<li>I&#x2F;O Polling 是什么？为什么要在执行已完成 I&#x2F;O 回调后阻塞 I&#x2F;O？Node 难道不是非阻塞的吗？</li>
</ol>
<p>让我们来解释这两个问题。</p>
<h2 id="Check-Handlers"><a href="#Check-Handlers" class="headerlink" title="Check Handlers"></a>Check Handlers</h2><p>NodeJS 初始化时，它会把所有 <code>setImmediate</code> 回调注册为 libuv 的 Check handlers。这意味着你使用 <code>setImmediate</code> 传入的回调会增加在 Libuv 的 Check handlers 队列中。它保证了这些回调会在事件循环中的 I&#x2F;O 操作后被执行。</p>
<h2 id="I-x2F-O-Polling"><a href="#I-x2F-O-Polling" class="headerlink" title="I&#x2F;O Polling"></a>I&#x2F;O Polling</h2><p>现在你应该在猜测 I&#x2F;O Polling 是什么。虽然我把 I&#x2F;O 回调队列和 I&#x2F;O Polling 合并为事件循环中的单一阶段，但实际上 I&#x2F;O Polling 发生在处理完已完成&#x2F;已错误的 I&#x2F;O 回调。</p>
<p>关于 I&#x2F;O Polling 最重要的事实是<strong>它是可选的</strong>。I&#x2F;O Polling 是否发生取决于当时的具体情况。为了彻底地了解它，我们看看 libuv 中的实现代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">r = uv__loop_alive(loop);</span><br><span class="line">  <span class="keyword">if</span> (!r)</span><br><span class="line">    uv__update_time(loop);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (r != <span class="number">0</span> &amp;&amp; loop-&gt;stop_flag == <span class="number">0</span>) &#123;</span><br><span class="line">    uv__update_time(loop);</span><br><span class="line">    uv__run_timers(loop);</span><br><span class="line">    ran_pending = uv__run_pending(loop);</span><br><span class="line">    uv__run_idle(loop);</span><br><span class="line">    uv__run_prepare(loop);</span><br><span class="line"></span><br><span class="line">    timeout = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT)</span><br><span class="line">      timeout = uv_backend_timeout(loop);</span><br><span class="line"></span><br><span class="line">    uv__io_poll(loop, timeout);</span><br><span class="line">    uv__run_check(loop);</span><br><span class="line">    uv__run_closing_handles(loop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mode == UV_RUN_ONCE) &#123;</span><br><span class="line">      uv__update_time(loop);</span><br><span class="line">      uv__run_timers(loop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = uv__loop_alive(loop);</span><br><span class="line">    <span class="keyword">if</span> (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对不熟悉 C 的人这段代码可能会人头痛。让我们尝试找到它的精髓而不过分关注细节。它来自于 libuv 源码的 <code>core.c</code> 文件的 <code>uv_run</code> 方法。但最重要的是，它是<strong>NodeJS 事件循环的核心</strong>。</p>
<p>让我们再看看图”Event loop and JavaScript”，它与代码可以对应起来。让我们一行行来解释代码：</p>
<ol>
<li><code>uv__loop_alive</code> —— 检查是否有待调用的被引用的处理器，或是否有活跃的挂起操作</li>
<li><code>uv__update_time</code> —— 发起系统调用获得当前时间，更新循环的时间（用于判断过期的计时器）</li>
<li><code>uv__run_timers</code> —— 运行所有过期的计时器</li>
<li><code>uv__run_pending</code> —— 运行所有已完成&#x2F;已错误的 I&#x2F;O 回调</li>
<li><code>uv__io_poll</code> —— Poll for I&#x2F;O</li>
<li><code>uv__run_check</code> —— 运行所有 check handlers（<code>setImmediate</code> 回调在此）</li>
<li><code>uv__run_closing_handles</code> —— 运行所有关闭处理器</li>
</ol>
<p>首先，事件循环通过调用 <code>uv__loop_alive</code> 函数检查事件循环是否依然存活。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">uv__loop_alive</span><span class="params">(<span class="type">const</span> <span class="type">uv_loop_t</span>* loop)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> uv__has_active_handles(loop) ||</span><br><span class="line">         uv__has_active_reqs(loop) ||</span><br><span class="line">         loop-&gt;closing_handles != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>uv__loop_alive</code> 函数返回 boolean 值。当满足以下条件时返回 <code>true</code>：</p>
<ol>
<li>存在待调用的活跃处理器</li>
<li>存在挂起的活跃请求或操作</li>
<li>存在待调用的关闭中的处理器</li>
</ol>
<p>只要 <code>uv__loop_alive</code> 返回 <code>true</code>，事件循环就会一直循环运行。</p>
<p>运行完所有过期定时器的回调后，<code>uv__run_pending</code> 会被调用。它会处理 libuv 储存所有已完成 I&#x2F;O 操作的 <code>pending_queue</code>。如果 <code>pending_queue</code> 为空，<code>uv__run_pending</code> 返回 0，否则执行队列中所有回调并返回 1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">uv__run_pending</span><span class="params">(<span class="type">uv_loop_t</span>* loop)</span> &#123;</span><br><span class="line">  QUEUE* q;</span><br><span class="line">  QUEUE pq;</span><br><span class="line">  <span class="type">uv__io_t</span>* w;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (QUEUE_EMPTY(&amp;loop-&gt;pending_queue))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  QUEUE_MOVE(&amp;loop-&gt;pending_queue, &amp;pq);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!QUEUE_EMPTY(&amp;pq)) &#123;</span><br><span class="line">    q = QUEUE_HEAD(&amp;pq);</span><br><span class="line">    QUEUE_REMOVE(q);</span><br><span class="line">    QUEUE_INIT(q);</span><br><span class="line">    w = QUEUE_DATA(q, <span class="type">uv__io_t</span>, pending_queue);</span><br><span class="line">    w-&gt;cb(loop, w, POLLOUT);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在让我们看看 libuv <code>uv__io_poll</code> 函数实现的 I&#x2F;O Polling。</p>
<p><code>uv__io_poll</code> 第二个参数是 <code>uv_backend_timeout</code> 计算出的超时时间。<code>uv__io_poll</code> 利用这一参数决定应该阻塞 I&#x2F;O 多长。如果超时时间为 0，I&#x2F;O polling 会被跳过，事件循环移动到 check handlers（<code>setImmediate</code>）阶段。什么决定 <code>timeout</code> 的值是很有趣的部分。根据之前 <code>uv_run</code> 的代码，我们可以推导出以下流程：</p>
<ol>
<li>如果事件循环以 <code>UV_RUN_DEFAULT</code> 模式运行，<code>timeout</code> 根据 <code>uv_backend_timeout</code> 方法计算得出</li>
<li>如果事件循环以 <code>UV_RUN_ONCE</code> 模式运行，并且 <code>uv_run_pending</code> 返回 0（例如 <code>pending_queue</code> 为空的情况），<code>timeout</code> 根据 <code>uv_backend_timeout</code> 方法计算得出</li>
<li>以上两种都不是则 <code>timeout</code> 为 <code>0</code></li>
</ol>
<blockquote>
<p>不需要太过关注事件循环的不同模式比如 <code>UV_RUN_DEFAULT</code> 和 <code>UV_RUN_ONCE</code>，如果你真的有兴趣，看<span class="exturl" data-url="aHR0cDovL2RvY3MubGlidXYub3JnL2VuL3YxLngvbG9vcC5odG1s">这里<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>让我们看看 <code>uv_backend_timeout</code> 代码，理解 <code>timeout</code> 是如何计算得出的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uv_backend_timeout</span><span class="params">(<span class="type">const</span> <span class="type">uv_loop_t</span>* loop)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (loop-&gt;stop_flag != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!uv__has_active_handles(loop) &amp;&amp; !uv__has_active_reqs(loop))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!QUEUE_EMPTY(&amp;loop-&gt;idle_handles))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!QUEUE_EMPTY(&amp;loop-&gt;pending_queue))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (loop-&gt;closing_handles)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> uv__next_timeout(loop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果 <code>stop_flag</code> 被设置，意味着事件循环将要退出，超时时间为 <code>0</code>。</li>
<li>如果没有活跃的 handles 和活跃的挂起状态的操作，不需要等待，因此超时时间为 <code>0</code>。</li>
<li>如果有待执行的挂起状态的空闲 handles，不等待 I&#x2F;0，因此超时时间为 <code>0</code>。</li>
<li>如果 <code>pending_queue</code> 中有已完成的 I&#x2F;O handlers，也不应该等待 I&#x2F;O，因此超时时间为 <code>0</code>。</li>
<li>如果存在挂起待执行的 close handlers，也不应该等待 I&#x2F;O，因此超时时间为 <code>0</code>。</li>
</ul>
<p>如果以上条件都不满足，<code>uv__next_timeout</code> 被调用来决定 libuv 应该为 I&#x2F;O 等待多长。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uv__next_timeout</span><span class="params">(<span class="type">const</span> <span class="type">uv_loop_t</span>* loop)</span> &#123;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">heap_node</span>* <span class="title">heap_node</span>;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">uv_timer_t</span>* handle;</span><br><span class="line">  <span class="type">uint64_t</span> diff;</span><br><span class="line"></span><br><span class="line">  heap_node = heap_min((<span class="type">const</span> <span class="keyword">struct</span> heap*) &amp;loop-&gt;timer_heap);</span><br><span class="line">  <span class="keyword">if</span> (heap_node == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* block indefinitely */</span></span><br><span class="line"></span><br><span class="line">  handle = container_of(heap_node, <span class="type">uv_timer_t</span>, heap_node);</span><br><span class="line">  <span class="keyword">if</span> (handle-&gt;timeout &lt;= loop-&gt;time)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  diff = handle-&gt;timeout - loop-&gt;time;</span><br><span class="line">  <span class="keyword">if</span> (diff &gt; INT_MAX)</span><br><span class="line">    diff = INT_MAX;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> diff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>uv__next_timeout</code> 负责返回离当前最近的定时器的值。如果没有，返回 <code>-1</code>，也就意味这无限。</p>
<p>现在你应该对问题“为什么要在执行已完成 I&#x2F;O 回调后阻塞 I&#x2F;O？Node 难道不是非阻塞的吗？”有答案了。</p>
<p>事件循环在存在待执行的挂起任务时不会阻塞，但如果不存在，循环就会一直阻塞直到有过期的定时器重新激活循环。</p>
<blockquote>
<p>我希望你还跟得上，虽然这些内容可能过于详细和细节。为了更好地理解事件循环，对底层机理的深入了解是很必要的。</p>
</blockquote>
<p>现在我们知道循环会等待多久 I&#x2F;O 变为已完成。<code>timeout</code> 被传入 <code>uv__io_poll</code>，<code>uv__io_poll</code> 一直等待进来的 I&#x2F;O 操作，直到达到超时时间或系统设置的最大安全超时时间。超时后，循环会激活，移动到 check handlers 阶段。</p>
<p>I&#x2F;O Polling 在不同的操作系统有不同的实现。Linux 中使用系统内核调用方法 <code>epoll_wait</code>，macOS 使用 <code>kqueue</code>，Windows 使用 IOCP(Input Output Completion Port) 中的 <code>GetQueuedCompletionStatus</code>。我不会具体探讨 I&#x2F;O Polling 如何工作，因为这个话题很复杂，至少要另外一个系列才能解释清楚（我不认为我会写）。</p>
<h2 id="关于线程池"><a href="#关于线程池" class="headerlink" title="关于线程池"></a>关于线程池</h2><p>这篇文章还没有谈到线程池。正如我们在本系统第一篇文章中提到的，线程池主要用来处理所有的文件 I&#x2F;O 操作，DNS 操作中的 <code>getaddrinfo</code> 和 <code>getnameinfo</code> 调用，因为不同操作系统文件 I&#x2F;O 的复杂性（对这个问题复杂度的确切分析看<span class="exturl" data-url="aHR0cDovL2Jsb2cubGlidG9ycmVudC5vcmcvMjAxMi8xMC9hc3luY2hyb25vdXMtZGlzay1pby8=">这里<i class="fa fa-external-link-alt"></i></span>）。因为线程池的大小是有限的（默认为 4），多个对文件系统的操作请求还是可能会被阻塞直到至少一个线程空闲可用。为了增加服务应用的性能，可通过环境变量 <code>UV_THREADPOOL_SIZE</code> 可将线程池的大小最大设为 128（截止这篇文章的时间）</p>
<p>但是线程池固定大小的限制仍然是 NodeJS 应用的一大瓶颈，因为线程池不仅仅只负责文件 I&#x2F;O，<code>getaddrinfo</code> 和 <code>getnameinfo</code>。一些特定 CPU 密集计算型的操作如加解密操作如 <code>randomBytes</code>, <code>randomFill</code> 和 <code>pbkdf2</code> 为了避免对应用的性能造成损害，也会在 libuv 线程池中运行。但这也可能导致线程成为 I&#x2F;O 操作所需的稀缺资源。</p>
<p>上一版 libuv 增强提案中有一点就是建议让线程池的大小可根据负载进行伸缩扩展。但是这项提案最终被<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpYnV2L2xlcHMvYmxvYi9tYXN0ZXIvMDA0LXRocmVhZHBvb2wtaGFuZGxlLm1k">撤回<i class="fa fa-external-link-alt"></i></span>，取而戴之的是未来会引入的一个关于线程的插件式 API，</p>
<p>本篇文章的一些内容受 Saúl Ibarra Corretgé 2016 年在 NodeConfEU 的演讲启发。如果你想更多了解 libuv，我强烈建议你观看这一<span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1zR1RSbVBpWEQ0WSZmZWF0dXJlPXlvdXR1LmJl">演讲视频<i class="fa fa-external-link-alt"></i></span>。</p>
]]></content>
      <categories>
        <category>编程</category>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>事件循环</tag>
      </tags>
  </entry>
  <entry>
    <title>（译文）NodeJS 事件循环（三）- Promises, Next-Ticks, and Immediates</title>
    <url>/2020/12/20/promises-next-ticks-and-immediates-nodejs-event-loop-part-3/</url>
    <content><![CDATA[<p>原文地址：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmluc2lkZXJhdHRhY2submV0L3Byb21pc2VzLW5leHQtdGlja3MtYW5kLWltbWVkaWF0ZXMtbm9kZWpzLWV2ZW50LWxvb3AtcGFydC0zLTkyMjZjYmU3YTZhYQ==">Promises, Next-Ticks, and Immediates— NodeJS Event Loop Part 3, Deepal Jayasekara, Jul 22, 2017<i class="fa fa-external-link-alt"></i></span></p>
<p>系列上篇文章 <a href="/2020/12/20/timers-immediates-and-process-nexttick-nodejs-event-loop-part-2/" title="（译文）NodeJS 事件循环（二）- Timers, Immediates 和 Process.nextTick">（译文）NodeJS 事件循环（二）- Timers, Immediates 和 Process.nextTick</a> 讲述了事件循环中的计时器，immediates 和每个队列如何按顺序执行。这篇文章将关注事件循环如何处理 resolved&#x2F;rejected promises (包括原生的 JS promises, Q promises, 和 Bluebird promises) 和 next tick 回调。如果你对 Promises 不熟悉，建议你先对 Promises 进行初步了解。</p>
<span id="more"></span>

<h2 id="原生-Promises"><a href="#原生-Promises" class="headerlink" title="原生 Promises"></a>原生 Promises</h2><blockquote>
<p>Node v11 引入了一些变化，对 <code>nextTick</code>，<code>Promise</code>，<code>setImmediate</code> 和 <code>setTimeout</code> 回调的执行顺序有巨大影响。详细介绍见 <span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BkcGpheWFzZWthcmEvbmV3LWNoYW5nZXMtdG8tdGltZXJzLWFuZC1taWNyb3Rhc2tzLWZyb20tbm9kZS12MTEtMC0wLWFuZC1hYm92ZS02OGQxMTI3NDNlYjM=">https://medium.com/@dpjayasekara/new-changes-to-timers-and-microtasks-from-node-v11-0-0-and-above-68d112743eb3<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>原生 promise 的回调被认为是一种微任务，并被添加到 microtask 队列，并紧接着 next tick 队列被处理。</p>
<p><img data-src="/2020/12/20/promises-next-ticks-and-immediates-nodejs-event-loop-part-3/1.all-Q.png"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1 resolved&#x27;</span>));</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2 resolved&#x27;</span>));</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise3 resolved&#x27;</span>);</span><br><span class="line">    process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next tick inside promise resolve handler&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise4 resolved&#x27;</span>));</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise5 resolved&#x27;</span>));</span><br><span class="line"><span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set immediate1&#x27;</span>));</span><br><span class="line"><span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set immediate2&#x27;</span>));</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next tick1&#x27;</span>));</span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next tick2&#x27;</span>));</span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next tick3&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set timeout&#x27;</span>), <span class="number">0</span>);</span><br><span class="line"><span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set immediate3&#x27;</span>));</span><br><span class="line"><span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set immediate4&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>以上代码的执行流程：</p>
<ol>
<li>5 个处理器添加到 resolved promises 微任务队列</li>
<li>2 个处理器添加到 <code>setImmediate</code> 队列</li>
<li>3 个 处理器添加到 <code>process.nextTick</code> 队列</li>
<li>1 个 计时器添加到计时器队列</li>
<li>2 个处理器添加到 <code>setImmediate</code> 队列</li>
</ol>
<p>事件循环开始：</p>
<ol>
<li>发现和处理 <code>process.nextTick</code> 队列中 3 个待处理项</li>
<li>发现和处理 promises 微任务队列中 5 个待处理项</li>
<li>处理 promises 微任务队列过程中一个新的待处理项添加到 <code>process.nextTick</code> 队列</li>
<li>promises 微任务队列处理完后发现 <code>process.nextTick</code> 队列有一个待处理项，开始处理</li>
<li><code>process.nextTick</code> 队列和 promises 微任务队列都为空后，移动到计时器队列，有 1 个过期计时器待处理，进行处理</li>
<li>无过期计时器待处理后，移动到 I&#x2F;O 阶段，因为没有挂起的 I&#x2F;O，继续移动到 <code>setImmediate</code> 队列处理 4 个待处理项</li>
<li>最后循环处理完所有事情，程序退出</li>
</ol>
<blockquote>
<p>为什么是 “promises microtask” 而不是 “microtask”？resolved&#x2F;rejected promises 和 <code>process.nextTick</code> 都是微任务 microtask。</p>
</blockquote>
<p>代码输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">next tick1</span><br><span class="line">next tick2</span><br><span class="line">next tick3</span><br><span class="line">promise1 resolved</span><br><span class="line">promise2 resolved</span><br><span class="line">promise3 resolved</span><br><span class="line">promise4 resolved</span><br><span class="line">promise5 resolved</span><br><span class="line">next tick inside promise resolve handler</span><br><span class="line">set timeout</span><br><span class="line">set immediate1</span><br><span class="line">set immediate2</span><br><span class="line">set immediate3</span><br><span class="line">set immediate4</span><br></pre></td></tr></table></figure>

<h2 id="Q-和-Bluebird"><a href="#Q-和-Bluebird" class="headerlink" title="Q 和 Bluebird"></a>Q 和 Bluebird</h2><p>我们现在知道 JS 原生 promises 的 resolve&#x2F;reject 回调会被当作微任务进行调度，并在每个阶段前被处理。Q 和 Bluebird 又是怎样？</p>
<p>NodeJS 实现原生 promises 前，人们使用 Q 和 Bluebird。因为 Q 和 Bluebird 先于原生 promises，它们有与原生 promises 不同的语义。</p>
<p>写这篇文件时， Q (v1.5.0) 使用 <code>process.nextTick</code> 队列来调度 resolved&#x2F;rejected promises 的回调。根据 Q 的文档：</p>
<blockquote>
<p>Note that resolution of a promise is always asynchronous: that is, the fulfillment or rejection handler will always be called in the next turn of the event loop (i.e. process.nextTick in Node). This gives you a nice guarantee when mentally tracing the flow of your code, namely that then will always return before either handler is executed.</p>
</blockquote>
<p>另一方面，Bluebird (v3.5.0) 默认使用 <code>setImmediate</code> 来调度 resolved&#x2F;rejected promises 的回调，代码见 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BldGthYW50b25vdi9ibHVlYmlyZC9ibG9iL21hc3Rlci9zcmMvc2NoZWR1bGUuanMjTDEy">这里<i class="fa fa-external-link-alt"></i></span>。</p>
<p>为了更清楚地认识，我们以下面的代码为例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Q = <span class="built_in">require</span>(<span class="string">&#x27;q&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">BlueBird</span> = <span class="built_in">require</span>(<span class="string">&#x27;bluebird&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;native promise resolved&#x27;</span>));</span><br><span class="line"><span class="title class_">BlueBird</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bluebird promise resolved&#x27;</span>));</span><br><span class="line"><span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set immediate&#x27;</span>));</span><br><span class="line">Q.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;q promise resolved&#x27;</span>));</span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next tick&#x27;</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set timeout&#x27;</span>), <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>上面的例子中，<code>BlueBird.resolve().then</code> 回调与 <code>setImmediate</code> 有相同的语义，因此 bluebird 的回调在 immediates 队列中，并在 <code>setImmediate</code> 回调之前。而 Q 使用 <code>process.nextTick</code> 来调度回调，<code>Q.resolve().then</code> 在 <code>process.nextTick</code> 队列并在 <code>process.nextTick</code> 回调之前。我们可以用如下输出来验证我们的推测：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">q promise resolved</span><br><span class="line">next tick</span><br><span class="line">native promise resolved</span><br><span class="line">set timeout</span><br><span class="line">bluebird promise resolved</span><br><span class="line">set immediate</span><br></pre></td></tr></table></figure>

<blockquote>
<p>虽然上面的例子只使用了 <code>resolve</code> promise，但 <code>reject</code> promise 的行为时一样的。文章最后，我会给一个同时有 <code>resolve</code> <code>reject</code> 的例子。</p>
</blockquote>
<p>Bluebird 给我们提供了一个选项，让我们可以选择调度机制。这意味着我们可以在 bluebird 用 <code>process.nextTick</code> 而不是 <code>setImmediate</code> 来实现 promise。Bluebird 提供 <code>setScheduler</code> 这个 API，它接收一个用于替换默认 <code>setImmediate</code> 调度方法的函数。</p>
<p>为了在 bluebird 中使用 <code>process.nextTick</code> 作为调度器，我们可以这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">BlueBird</span> = <span class="built_in">require</span>(<span class="string">&#x27;bluebird&#x27;</span>);</span><br><span class="line"><span class="title class_">BlueBird</span>.<span class="title function_">setScheduler</span>(process.<span class="property">nextTick</span>);</span><br></pre></td></tr></table></figure>

<p>想使用 <code>setTimeout</code> 则可以：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">BlueBird</span> = <span class="built_in">require</span>(<span class="string">&#x27;bluebird&#x27;</span>);</span><br><span class="line"><span class="title class_">BlueBird</span>.<span class="title function_">setScheduler</span>(<span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(fn, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>为了防止文章过长，我这里不再赘述各种使用样例。你可以尽情尝试不同的调度器，查看输出结果。</p>
<p>在新版本 node 中使用 <code>setImmediate</code> 替代 <code>process.nextTick</code> 有它的好处、因为从 NodeJS v0.12 开始，不再有 <code>process.maxTickDepth</code>，过多添加事件到 nextTick 队列会导致 I&#x2F;O 饿死。而 immediates 队列在 I&#x2F;O 队列之后，因此用 <code>setImmediate</code> 替代 <code>process.nextTick</code> 能够避免这种情况。</p>
<h2 id="最后的例子"><a href="#最后的例子" class="headerlink" title="最后的例子"></a>最后的例子</h2><p>以下代码会产生有点复杂难懂的输出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Q = <span class="built_in">require</span>(<span class="string">&#x27;q&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">BlueBird</span> = <span class="built_in">require</span>(<span class="string">&#x27;bluebird&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;native promise resolved&#x27;</span>));</span><br><span class="line"><span class="title class_">BlueBird</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bluebird promise resolved&#x27;</span>));</span><br><span class="line"><span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set immediate&#x27;</span>));</span><br><span class="line">Q.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;q promise resolved&#x27;</span>));</span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next tick&#x27;</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set timeout&#x27;</span>), <span class="number">0</span>);</span><br><span class="line">Q.<span class="title function_">reject</span>().<span class="title function_">catch</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;q promise rejected&#x27;</span>));</span><br><span class="line"><span class="title class_">BlueBird</span>.<span class="title function_">reject</span>().<span class="title function_">catch</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bluebird promise rejected&#x27;</span>));</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>().<span class="title function_">catch</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;native promise rejected&#x27;</span>));</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">q promise resolved</span><br><span class="line">q promise rejected</span><br><span class="line">next tick</span><br><span class="line">native promise resolved</span><br><span class="line">native promise rejected</span><br><span class="line">set timeout</span><br><span class="line">bluebird promise resolved</span><br><span class="line">bluebird promise rejected</span><br><span class="line">set immediate</span><br></pre></td></tr></table></figure>

<p>你应该会有两个问题：</p>
<ol>
<li>如果 Q 使用 <code>process.nextTick</code>，为什么 <code>q promise rejected</code> 在 <code>next tick</code> 之前？</li>
<li>如果 Bluebird 使用 <code>setImmediate</code>，为什么 <code>bluebird promise rejected</code> 在 <code>set immediate</code> 之前？</li>
</ol>
<p>这是因为两个库都有一个内部的队列来存放所有 resolved&#x2F;rejected promise 回调，然后把这个内部队列添加到事件循环对应的队列中，这样事件循环就会一次性处理内部队列中所有的回调。更详细解释见 <span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BkcGpheWFzZWthcmEvaGktbWF4aW0tMWI5N2Y4M2JjZDhm">这里<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>编程</category>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>事件循环</tag>
      </tags>
  </entry>
  <entry>
    <title>（译文）NodeJS 事件循环（二）- Timers, Immediates 和 Process.nextTick</title>
    <url>/2020/12/20/timers-immediates-and-process-nexttick-nodejs-event-loop-part-2/</url>
    <content><![CDATA[<p>原文地址：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmluc2lkZXJhdHRhY2submV0L3RpbWVycy1pbW1lZGlhdGVzLWFuZC1wcm9jZXNzLW5leHR0aWNrLW5vZGVqcy1ldmVudC1sb29wLXBhcnQtMi0yYzUzZmQ1MTFiYjM=">Timers, Immediates and Process.nextTick— NodeJS Event Loop Part 2, Deepal Jayasekara, May 11, 2017<i class="fa fa-external-link-alt"></i></span></p>
<p>上篇文章 <a href="/2020/12/20/event-loop-and-the-big-picture-nodejs-event-loop-part-1/" title="（译文）NodeJS 事件循环（一）- 事件循环机制概述">（译文）NodeJS 事件循环（一）- 事件循环机制概述</a> 中我讲述了 NodeJS 事件循环的总体图景。这篇文章中，我将详细讨论三个重要的队列：timers, immediates and process.nextTick 回调。</p>
<span id="more"></span>

<h2 id="Next-Tick-Queue"><a href="#Next-Tick-Queue" class="headerlink" title="Next Tick Queue"></a>Next Tick Queue</h2><p><img data-src="/2020/12/20/timers-immediates-and-process-nexttick-nodejs-event-loop-part-2/1.all-Q.png"></p>
<p>Next tick 队列与其他 4 个主要队列分隔开，是因为它不是 libuv 原生提供的，而是 Node 自己实现的。</p>
<p>事件循环中要移动到一个阶段前（timers queue, IO events queue, immediates queue, close handlers queue 是 4 个主要的阶段），Node 会检查 <code>nextTick</code> 队列是否为空。如果不为空，Node 会一直处理该队列直到不为空。</p>
<blockquote>
<p>Node v11 引入了一些变化，导致巨大的行为差异。详细介绍见: <span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BkcGpheWFzZWthcmEvbmV3LWNoYW5nZXMtdG8tdGltZXJzLWFuZC1taWNyb3Rhc2tzLWZyb20tbm9kZS12MTEtMC0wLWFuZC1hYm92ZS02OGQxMTI3NDNlYjM=">https://medium.com/@dpjayasekara/new-changes-to-timers-and-microtasks-from-node-v11-0-0-and-above-68d112743eb3<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>这引入了一个问题：通过 <code>process.nextTick</code> 递归或重复添加事件到 <code>nextTick</code> 队列会导致 I&#x2F;O 和其他队列一直无法被处理。以下代码为例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addNextTickRecurs</span>(<span class="params">count</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">id</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        self.<span class="property">id</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">id</span> === count) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`process.nextTick call <span class="subst">$&#123;++self.id&#125;</span>`</span>);</span><br><span class="line">        addNextTickRecurs.<span class="title function_">call</span>(self, count);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">addNextTickRecurs</span>(<span class="title class_">Infinity</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>.<span class="title function_">bind</span>(<span class="variable language_">console</span>, <span class="string">&#x27;omg! setTimeout was called&#x27;</span>), <span class="number">10</span>);</span><br><span class="line"><span class="title function_">setImmediate</span>(<span class="variable language_">console</span>.<span class="property">log</span>.<span class="title function_">bind</span>(<span class="variable language_">console</span>, <span class="string">&#x27;omg! setImmediate also was called&#x27;</span>));</span><br><span class="line">fs.<span class="title function_">readFile</span>(__filename, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;omg! file read complete callback was called!&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;started&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>你将看到输出中没有 ‘omg!…’， 全是 <code>nextTick</code> 回调的无限循环，而 <code>setTimeout</code>, <code>setImmediate</code> 和 <code>fs.readFile</code> 回调永远不会被调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">started</span><br><span class="line">process.nextTick call 1</span><br><span class="line">process.nextTick call 2</span><br><span class="line">process.nextTick call 3</span><br><span class="line">process.nextTick call 4</span><br><span class="line">process.nextTick call 5</span><br><span class="line">process.nextTick call 6</span><br><span class="line">process.nextTick call 7</span><br><span class="line">process.nextTick call 8</span><br><span class="line">process.nextTick call 9</span><br><span class="line">process.nextTick call 10</span><br><span class="line">process.nextTick call 11</span><br><span class="line">process.nextTick call 12</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>当你把 <code>addNextTickRecurs</code> 的入参设为有限值时，你将在 <strong>process.nextTick call</strong> 的末尾看到<code>setTimeout</code>, <code>setImmediate</code> 和 <code>fs.readFile</code> 的回调输出。</p>
<blockquote>
<p>Node v0.12 之前, 有一个属性 <code>process.maxTickDepth</code> 用于限制 <code>process.nextTick</code> 队列的长度。当它被手动设置后，Node 一次只会处理 next tick queue 中不多于 <code>maxTickDepth</code> 的回调。但这个属性在 Node v0.12 中被移除。因此，在更新版本的 Node 中，应避免重复添加事件到 next tick queue。</p>
</blockquote>
<h2 id="Timers-queue"><a href="#Timers-queue" class="headerlink" title="Timers queue"></a>Timers queue</h2><p>当你使用 <code>setTimeout</code> 或 <code>setInterval</code> 时，Node 将会添加计时器到 libuv 的计时器堆。事件循环中轮到计时器阶段时，Node 将会检查计时器堆中过期的计时器，并按它们设置的先后顺序依次调用它们的回调。</p>
<p>计时器<strong>并不能</strong>精确保证回调会在过期时间到时被执行。计时器回调的执行时机取决于操作系统（Node 必须在执行回调前检查计时器的过期时间，而这一过程会消耗一定的 CPU 时间）和事件循环中当前进程的表现。更准确地说，计时器保证的是回调不会在过期时间未到前被执行。我们可以用以下代码来模拟这种情况</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> start = process.<span class="title function_">hrtime</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> end = process.<span class="title function_">hrtime</span>(start);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`timeout callback executed after <span class="subst">$&#123;end[<span class="number">0</span>]&#125;</span>s and <span class="subst">$&#123;end[<span class="number">1</span>]/<span class="built_in">Math</span>.pow(<span class="number">10</span>,<span class="number">9</span>)&#125;</span>ms`</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>上述代码在程序开始时设置一个过期时间为 1 秒的计时器，并打印到实际执行回调用了多长时间。如果你多次运行这段代码，你将注意到它每次都会打印不同的结果，并且永远不会打印 <code>timeout callback executed after 1s and 0ms</code>。你将看到类似下面的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">timeout callback executed after 1s and 0.006058353ms</span><br><span class="line">timeout callback executed after 1s and 0.004489878ms</span><br><span class="line">timeout callback executed after 1s and 0.004307132ms</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这种时间过期的本质导致当 <code>setTimeout</code> 与 <code>setImmediate</code> 一起使用时会有意想不到的结果。我将在后面章节详细讲述。</p>
<h3 id="Immediates-Queue"><a href="#Immediates-Queue" class="headerlink" title="Immediates Queue"></a>Immediates Queue</h3><p>虽然 immediates 队列和计时器过期的行为非常相似，但它有自己的特点。不像计时器我们无法保证它的回调什么时候被执行（即使把过期时间设为 0），immediates 队列保证了它会在事件循环的 I&#x2F;O 阶段后立即被处理。通过 <code>setImmediate</code> 可以向 immediates 队列添加事件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi, this is an immediate&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="setTimeout-vs-setImmediate"><a href="#setTimeout-vs-setImmediate" class="headerlink" title="setTimeout vs setImmediate ?"></a>setTimeout vs setImmediate ?</h2><p>让我们看看文章开头的事件循环图，你会看到当程序开始时 Node 从处理计时器队列开始，处理完 I&#x2F;O 后再轮到 immediates 队列。根据图上的逻辑，我们可以推测以下代码的输出。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="title function_">setImmediate</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setImmediate&#x27;</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>你会推测上面的代码总是会先打印 <code>setTimeout</code> 再打印 <code>setImmediate</code>，因为过期计时器队列比 immediates 先处理。但实际这段代码无法保证这样的输出结果。你多次运行这段代码，会得到不同的输出结果。</p>
<p>这是因为 NodeJS 为了对齐 <span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL2JsaW5rLysvbWFzdGVyL1NvdXJjZS9jb3JlL2ZyYW1lL0RPTVRpbWVyLmNwcCM5Mw==">Chrome’s timers cap<i class="fa fa-external-link-alt"></i></span>，把最小过期时间定为 <code>1ms</code>。所以即使你把过期时间设为 <code>0ms</code>，会被覆盖为 <code>1ms</code>。</p>
<blockquote>
<p>如果你想知道更多这一点上 Node 和不同浏览器的行为差异，请看 <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmluc2lkZXJhdHRhY2submV0L2phdmFzY3JpcHQtZXZlbnQtbG9vcC12cy1ub2RlLWpzLWV2ZW50LWxvb3AtYWVhMmIxYjg1ZjVj">javascript-event-loop-vs-node-js-event-loop<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>每次新的事件循环开始时，NodeJS 通过系统调用获得当前时钟。根据 CPU 的繁忙情况，获取当前时钟的操作耗时可能不超过也可能超过 <code>1ms</code>。如果少于 <code>1ms</code>，NodeJS 将认为这个计时器还没过期，因为过期时间是 <code>1ms</code>，这时事件循环会移动到 I&#x2F;O 阶段再到 immediates 队列，然后发现队列中有一个事件并进行处理，也就意味着 <code>setImmediate</code> 比 <code>setTimeout</code> 先执行。但如果耗时超过 <code>1ms</code>，计时器就会被认为已过期，执行顺序结果相反。</p>
<p>下面中代码保证了 immediate 一定会比计时器的先执行。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(__filename, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">    <span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;immediate&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>让我们看看上述代码的执行流程</p>
<ol>
<li>开始，程序异步读取文件，并提供一个处理文件读取完毕的回调。</li>
<li>事件循环开始</li>
<li>当文件读取完毕，执行回调作为一个事件添加到 I&#x2F;O 队列</li>
<li>因为没有其他事件，Node 会一直等待 I&#x2F;O 事件，然后发现 I&#x2F;O 队列有一个事件，开始执行回调</li>
<li>执行回调过程中，一个计时器添加到计时器堆，一个 immediate 添加到 immediate 队列</li>
<li>现在事件循环正处在 I&#x2F;O 阶段，因为没有要处理的 I&#x2F;O 事件，事件循环会移动到 immediate 阶段，发现有一个 immediate 回调，然后 immediate 回调被执行</li>
<li>下一轮事件循环发现有一个过期的计时器，然后执行计时器回调</li>
</ol>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>看看事件循环中不同阶段&#x2F;队列如何一起工作，以下面的代码为例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this is set immediate 1&#x27;</span>));</span><br><span class="line"><span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this is set immediate 2&#x27;</span>));</span><br><span class="line"><span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this is set immediate 3&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this is set timeout 1&#x27;</span>), <span class="number">0</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this is set timeout 2&#x27;</span>);</span><br><span class="line">    process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this is process.nextTick added inside setTimeout&#x27;</span>));</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this is set timeout 3&#x27;</span>), <span class="number">0</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this is set timeout 4&#x27;</span>), <span class="number">0</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this is set timeout 5&#x27;</span>), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this is process.nextTick 1&#x27;</span>));</span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    process.<span class="title function_">nextTick</span>(<span class="variable language_">console</span>.<span class="property">log</span>.<span class="title function_">bind</span>(<span class="variable language_">console</span>, <span class="string">&#x27;this is the inner next tick inside next tick&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this is process.nextTick 2&#x27;</span>));</span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this is process.nextTick 3&#x27;</span>));</span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this is process.nextTick 4&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>执行上面的代码后，以下事件被添加到对应的事件循环队列</p>
<ul>
<li>3 immediates</li>
<li>5 timer callbacks</li>
<li>5 next tick callbacks</li>
</ul>
<p>执行流程是这样：</p>
<ol>
<li>事件循环开始，发现 next tick 队列不为空，开始处理 next tick callbacks。执行第二个 next tick callback 时一个新的 next tick callback 添加到队列末尾，并在最后被执行。</li>
<li>执行计时器队列中过期的计时器。执行第二个计时器回调时，一个新的 next tick callback 添加到 next tick 队列。</li>
<li>当所有过期计时器执行完，事件循环检查 next tick 队列有一个事件并执行。</li>
<li>因为没有 I&#x2F;O 事件，事件循环移动到 immediates 阶段开始处理 immediates 队列。</li>
</ol>
<p>代码运行结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this is process.nextTick 1</span><br><span class="line">this is process.nextTick 2</span><br><span class="line">this is process.nextTick 3</span><br><span class="line">this is process.nextTick 4</span><br><span class="line">this is the inner next tick inside next tick</span><br><span class="line">this is set timeout 1</span><br><span class="line">this is set timeout 2</span><br><span class="line">this is set timeout 3</span><br><span class="line">this is set timeout 4</span><br><span class="line">this is set timeout 5</span><br><span class="line">this is process.nextTick added inside setTimeout</span><br><span class="line">this is set immediate 1</span><br><span class="line">this is set immediate 2</span><br><span class="line">this is set immediate 3</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程</category>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>事件循环</tag>
      </tags>
  </entry>
  <entry>
    <title>常用软件集锦</title>
    <url>/2022/04/03/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E9%9B%86%E9%94%A6/</url>
    <content><![CDATA[<p>记录常用的一些软件</p>
<span id="more"></span>

<ul>
<li>文件搜索<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudm9pZHRvb2xzLmNvbS96aC1jbi9kb3dubG9hZHMv">Everything<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cubGlzdGFyeS5jb20vZG93bmxvYWQ=">Listary<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
<li>解压缩工具<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuNy16aXAub3JnL2Rvd25sb2FkLmh0bWw=">7-zip<i class="fa fa-external-link-alt"></i></span></li>
<li>Bandizip</li>
<li>WinRAR</li>
</ul>
</li>
<li>视频播放器<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9wb3RwbGF5ZXIuZGF1bS5uZXQv">Potplayer<i class="fa fa-external-link-alt"></i></span></li>
<li>IINA</li>
</ul>
</li>
<li>卡片式记忆辅助<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9hcHBzLmFua2l3ZWIubmV0Lw==">Anki<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
<li>截图软件<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly96aC5zbmlwYXN0ZS5jb20vZG93bmxvYWQuaHRtbA==">Snipaste<i class="fa fa-external-link-alt"></i></span></li>
<li>iShot</li>
</ul>
</li>
<li>GIF录制<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmJhaHJhbmlhcHBzLmNvbS9naWZjYW0v">GIFcam<i class="fa fa-external-link-alt"></i></span></li>
<li>ScreenToGif</li>
<li>LICEcap</li>
</ul>
</li>
<li>电子书管理<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9jYWxpYnJlLWVib29rLmNvbS9kb3dubG9hZA==">Calibre<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
<li>笔记<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9iM2xvZy5vcmcvc2l5dWFuL2Rvd25sb2FkLmh0bWw=">思源笔记<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
<li>文件同步<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9mcmVlZmlsZXN5bmMub3JnLw==">FreeFileSync<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>常用软件</category>
      </categories>
      <tags>
        <tag>常用软件</tag>
      </tags>
  </entry>
  <entry>
    <title>平面 n 点求共线</title>
    <url>/2020/11/24/%E5%B9%B3%E9%9D%A2N%E7%82%B9%E6%B1%82%E5%85%B1%E7%BA%BF/</url>
    <content><![CDATA[<p>给定平面 n 个离散点，找出所有至少 4 个点在线上的线段，若 p q r s t 按顺序共线，则只返回最长的线段 pt 或 tp，时间复杂度要求：(N^2)logN</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>n 个点中选中一个点 A1 作为原点，其他点按与 A1 的斜率排序，斜率相同的一组点则为共线点。得到一组共线点后需找出该线段的起始点，可通过横纵坐标比大小排序得出。n 个点如此循环操作一次即可得到所有线段。对于线段去重，考虑 A1，A2，A2，A3，A4 共线，设 A2 为线段起点，则这 4 个点分别作为原点时，都必然得到 A2 开始的线段，由此可得只对原点与线段起点相同的情况进行计数，则可以避免线段重复问题</p>
<h2 id="typescript-简版代码"><a href="#typescript-简版代码" class="headerlink" title="typescript 简版代码"></a>typescript 简版代码</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY291cnNlcmEub3JnL2xlYXJuL2FsZ29yaXRobXMtcGFydDEvcHJvZ3JhbW1pbmcvcHJYaVcvY29sbGluZWFyLXBvaW50cw==">coursera 算法课程习题<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> x: <span class="built_in">number</span>, <span class="keyword">private</span> y: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">isSameSlope</span>(<span class="params">slope: <span class="built_in">number</span>, currentSlope: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">abs</span>(slope - currentSlope) &lt;= <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">1</span>, -<span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">compare</span>(<span class="params">otherA: Point, otherB: Point</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> otherA.<span class="property">y</span> !== otherB.<span class="property">y</span></span><br><span class="line">            ? otherA.<span class="property">y</span> - otherB.<span class="property">y</span></span><br><span class="line">            : otherA.<span class="property">x</span> - otherB.<span class="property">x</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">isSame</span>(<span class="params">other: Point</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">x</span> === other.<span class="property">x</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">y</span> === other.<span class="property">y</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">slopeTo</span>(<span class="params">other: Point</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isSame</span>(other)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Number</span>.<span class="property">NEGATIVE_INFINITY</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> deltaX = other.<span class="property">x</span> - <span class="variable language_">this</span>.<span class="property">x</span></span><br><span class="line">        <span class="keyword">const</span> deltaY = other.<span class="property">y</span> - <span class="variable language_">this</span>.<span class="property">y</span></span><br><span class="line">        <span class="keyword">return</span> deltaX === <span class="number">0</span> ? <span class="title class_">Number</span>.<span class="property">POSITIVE_INFINITY</span> : deltaY / deltaX</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">comparator</span>(<span class="params">otherA: Point, otherB: Point</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> slopeA = <span class="variable language_">this</span>.<span class="title function_">slopeTo</span>(otherA)</span><br><span class="line">        <span class="keyword">const</span> slopeB = <span class="variable language_">this</span>.<span class="title function_">slopeTo</span>(otherB)</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title class_">Point</span>.<span class="title function_">isSameSlope</span>(slopeA, slopeB)) <span class="keyword">return</span> slopeA - slopeB</span><br><span class="line">        <span class="keyword">return</span> otherA.<span class="property">y</span> !== otherB.<span class="property">y</span></span><br><span class="line">            ? otherA.<span class="property">y</span> - otherB.<span class="property">y</span></span><br><span class="line">            : otherA.<span class="property">x</span> - otherB.<span class="property">x</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LineSegment</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> p1: Point, <span class="keyword">private</span> p2: Point</span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">solve</span>(<span class="params">pointList: Point[]</span>) &#123;</span><br><span class="line">    <span class="comment">// 以下只考虑一般情况：pointList 长度大于等于 4，不存在重复点</span></span><br><span class="line">    <span class="keyword">const</span> minCollinearPointsNum = <span class="number">4</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">lineSegment</span>: <span class="title class_">LineSegment</span>[] = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">pointListCopy</span>: <span class="title class_">Point</span>[] = pointList.<span class="title function_">map</span>(<span class="function"><span class="params">e</span> =&gt;</span> e)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleCollinearPointGroup</span> = (<span class="params">startIndex: <span class="built_in">number</span>, endIndex: <span class="built_in">number</span>, startPoint: Point, pList: Point[]</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (endIndex - startIndex &gt;= minCollinearPointsNum - <span class="number">2</span>) &#123;</span><br><span class="line">            lineSegment.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">LineSegment</span>(startPoint, pList[endIndex]))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> point <span class="keyword">of</span> pointList) &#123;</span><br><span class="line">        pointListCopy.<span class="title function_">sort</span>(point.<span class="property">comparator</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> startIndex = <span class="number">1</span>  <span class="comment">// index 0 必定是 point 自身</span></span><br><span class="line">        <span class="keyword">let</span> endIndex = <span class="number">1</span></span><br><span class="line">        <span class="keyword">let</span> flag = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">let</span> currentSlope = <span class="title class_">Number</span>.<span class="property">NEGATIVE_INFINITY</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> index = startIndex; index &lt; pointListCopy.<span class="property">length</span>; index++) &#123;</span><br><span class="line">            <span class="keyword">const</span> element = pointListCopy[index]</span><br><span class="line">            <span class="keyword">const</span> slope = point.<span class="title function_">slopeTo</span>(element)</span><br><span class="line">            <span class="keyword">if</span> (!<span class="title class_">Point</span>.<span class="title function_">isSameSlope</span>(slope, currentSlope)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (flag) <span class="title function_">handleCollinearPointGroup</span>(startIndex, endIndex, point, pointListCopy)</span><br><span class="line">                flag = <span class="title class_">Point</span>.<span class="title function_">compare</span>(point, element) &lt; <span class="number">0</span>  <span class="comment">// 除原点外的第一个点如果比原点大，则原点为线段起点</span></span><br><span class="line">                startIndex = index</span><br><span class="line">                endIndex = index</span><br><span class="line">                currentSlope = slope</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                endIndex++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="title function_">handleCollinearPointGroup</span>(startIndex, endIndex, point, pointListCopy)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lineSegment <span class="keyword">as</span> <span class="keyword">readonly</span> <span class="title class_">LineSegment</span>[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="java-完全版代码"><a href="#java-完全版代码" class="headerlink" title="java 完全版代码"></a>java 完全版代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Point</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Point&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> x;     <span class="comment">// x-coordinate of this point</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> y;     <span class="comment">// y-coordinate of this point</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes a new point.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  x the &lt;em&gt;x&lt;/em&gt;-coordinate of the point</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  y the &lt;em&gt;y&lt;/em&gt;-coordinate of the point</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="comment">/* DO NOT MODIFY */</span></span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the slope between this point and the specified point.</span></span><br><span class="line"><span class="comment">     * Formally, if the two points are (x0, y0) and (x1, y1), then the slope</span></span><br><span class="line"><span class="comment">     * is (y1 - y0) / (x1 - x0). For completeness, the slope is defined to be</span></span><br><span class="line"><span class="comment">     * +0.0 if the line segment connecting the two points is horizontal;</span></span><br><span class="line"><span class="comment">     * Double.POSITIVE_INFINITY if the line segment is vertical;</span></span><br><span class="line"><span class="comment">     * and Double.NEGATIVE_INFINITY if (x0, y0) and (x1, y1) are equal.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  that the other point</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the slope between this point and the specified point</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">slopeTo</span><span class="params">(Point that)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">deltaX</span> <span class="operator">=</span> that.x - x;</span><br><span class="line">        <span class="type">int</span> <span class="variable">deltaY</span> <span class="operator">=</span> that.y - y;</span><br><span class="line">        <span class="keyword">if</span> (deltaX == <span class="number">0</span> &amp;&amp; deltaY == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Double.NEGATIVE_INFINITY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deltaX == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Double.POSITIVE_INFINITY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deltaY == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> +<span class="number">0.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">double</span>) deltaY / deltaX;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Compares two points by y-coordinate, breaking ties by x-coordinate.</span></span><br><span class="line"><span class="comment">     * Formally, the invoking point (x0, y0) is less than the argument point</span></span><br><span class="line"><span class="comment">     * (x1, y1) if and only if either y0 &lt; y1 or if y0 = y1 and x0 &lt; x1.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  that the other point</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the value &lt;tt&gt;0&lt;/tt&gt; if this point is equal to the argument</span></span><br><span class="line"><span class="comment">     *         point (x0 = x1 and y0 = y1);</span></span><br><span class="line"><span class="comment">     *         a negative integer if this point is less than the argument</span></span><br><span class="line"><span class="comment">     *         point; and a positive integer if this point is greater than the</span></span><br><span class="line"><span class="comment">     *         argument point</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Point that)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &gt; that.y) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y &lt; that.y) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> Integer.compare(x, that.x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Compares two points by the slope they make with this point.</span></span><br><span class="line"><span class="comment">     * The slope is defined as in the slopeTo() method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the Comparator that defines this ordering on points</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Comparator&lt;Point&gt; <span class="title function_">slopeOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Point a, Point b) -&gt; &#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">slopA</span> <span class="operator">=</span> slopeTo(a);</span><br><span class="line">            <span class="type">double</span> <span class="variable">slopB</span> <span class="operator">=</span> slopeTo(b);</span><br><span class="line">            <span class="keyword">return</span> Double.compare(slopA, slopB);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a string representation of this point.</span></span><br><span class="line"><span class="comment">     * This method is provide for debugging;</span></span><br><span class="line"><span class="comment">     * your program should not rely on the format of the string representation.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a string representation of this point</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/* DO NOT MODIFY */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + x + <span class="string">&quot;, &quot;</span> + y + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LineSegment</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Point p;   <span class="comment">// one endpoint of this line segment</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Point q;   <span class="comment">// the other endpoint of this line segment</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes a new line segment.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  p one endpoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  q the other endpoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if either &lt;tt&gt;p&lt;/tt&gt; or &lt;tt&gt;q&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     *         is &lt;tt&gt;null&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LineSegment</span><span class="params">(Point p, Point q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || q == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;argument is null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.p = p;</span><br><span class="line">        <span class="built_in">this</span>.q = q;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a string representation of this line segment</span></span><br><span class="line"><span class="comment">     * This method is provide for debugging;</span></span><br><span class="line"><span class="comment">     * your program should not rely on the format of the string representation.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a string representation of this line segment</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p + <span class="string">&quot; -&gt; &quot;</span> + q;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Throws an exception if called. The hashCode() method is not supported because</span></span><br><span class="line"><span class="comment">     * hashing has not yet been introduced in this course. Moreover, hashing does not</span></span><br><span class="line"><span class="comment">     * typically lead to good *worst-case* performance guarantees, as required on this</span></span><br><span class="line"><span class="comment">     * assignment.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException if called</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastCollinearPoints</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LineSegment[] result;</span><br><span class="line">    <span class="comment">// finds all line segments containing 4 or more points</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FastCollinearPoints</span><span class="params">(Point[] points)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (points == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Point[] pointsCopy1 = points.clone();</span><br><span class="line">        Point[] pointsCopy2 = points.clone();</span><br><span class="line">        ArrayList&lt;LineSegment&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pointsCopy1.length; i++) &#123;</span><br><span class="line">            <span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> getPoint(pointsCopy1, i);</span><br><span class="line">            Arrays.sort(pointsCopy2, <span class="number">0</span>, pointsCopy2.length, FastCollinearPoints.slopeOrder(p));</span><br><span class="line">            <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">endIndex</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="type">double</span> <span class="variable">slope</span> <span class="operator">=</span> Double.NEGATIVE_INFINITY;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> startIndex; j &lt; pointsCopy2.length; j++) &#123;</span><br><span class="line">                <span class="type">Point</span> <span class="variable">c</span> <span class="operator">=</span> getPoint(pointsCopy2, j);</span><br><span class="line">                <span class="type">double</span> <span class="variable">cSlope</span> <span class="operator">=</span> c.slopeTo(p);</span><br><span class="line">                <span class="keyword">if</span> (cSlope == Double.NEGATIVE_INFINITY) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cSlope == slope) &#123;</span><br><span class="line">                    endIndex++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (flag &amp;&amp; (endIndex - startIndex) &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                        <span class="type">LineSegment</span> <span class="variable">lineSegment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LineSegment</span>(p, points[endIndex]);</span><br><span class="line">                        list.add(lineSegment);</span><br><span class="line">                    &#125;</span><br><span class="line">                    flag = c.compareTo(p) &gt; <span class="number">0</span>;</span><br><span class="line">                    startIndex = j;</span><br><span class="line">                    endIndex = j;</span><br><span class="line">                    slope = cSlope;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag &amp;&amp; (endIndex - startIndex) &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="type">LineSegment</span> <span class="variable">lineSegment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LineSegment</span>(p, points[endIndex]);</span><br><span class="line">                list.add(lineSegment);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="keyword">new</span> <span class="title class_">LineSegment</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            result[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparator&lt;Point&gt; <span class="title function_">slopeOrder</span><span class="params">(Point p)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Point a, Point b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="literal">null</span> || b == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">            <span class="type">double</span> <span class="variable">slopA</span> <span class="operator">=</span> p.slopeTo(a);</span><br><span class="line">            <span class="type">double</span> <span class="variable">slopB</span> <span class="operator">=</span> p.slopeTo(b);</span><br><span class="line">            <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Double.compare(slopA, slopB);</span><br><span class="line">            <span class="keyword">if</span> (res == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> a.compareTo(b);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Point <span class="title function_">getPoint</span><span class="params">(Point[] points, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> points[index];</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the number of line segments</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfSegments</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> result.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the line segments</span></span><br><span class="line">    <span class="keyword">public</span> LineSegment[] segments() &#123;</span><br><span class="line">        <span class="keyword">return</span> result.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>题目</category>
      </categories>
      <tags>
        <tag>算法题</tag>
      </tags>
  </entry>
  <entry>
    <title>廿一史弹词</title>
    <url>/2020/07/10/%E5%BB%BF%E4%B8%80%E5%8F%B2%E5%BC%B9%E8%AF%8D/</url>
    <content><![CDATA[<p>作者：杨慎　明</p>
<h2 id="第一段-总说"><a href="#第一段-总说" class="headerlink" title="第一段 总说"></a>第一段 总说</h2><h3 id="西江月"><a href="#西江月" class="headerlink" title="西江月"></a>西江月</h3><pre><code>天上乌飞兔走，人间古往今来。沉吟屈指数英才，多少是非成败。
富贵歌楼舞榭，凄凉废冢荒台。万般回首化尘埃，只有青山不改。
</code></pre>
<h3 id="西江月-1"><a href="#西江月-1" class="headerlink" title="西江月"></a>西江月</h3><pre><code>滚滚龙争虎斗，匆匆兔走乌飞。席前花影坐间移，百岁光阴有几。
说古谈今话本，图王霸业兵机。要知成败是和非，都在渔樵话里。
</code></pre>
<span id="more"></span>

<h2 id="第二段-说三代"><a href="#第二段-说三代" class="headerlink" title="第二段 说三代"></a>第二段 说三代</h2><h3 id="南乡子"><a href="#南乡子" class="headerlink" title="南乡子"></a>南乡子</h3><pre><code>携酒上吟亭，满目江山列画屏。赚得英雄头似霉，功名。虎啸龙吟几战争。
一枕梦魂惊，落叶西风别换声。谁弱谁强都罢手，伤情。打入渔樵话里听。
</code></pre>
<h3 id="西江月-2"><a href="#西江月-2" class="headerlink" title="西江月"></a>西江月</h3><pre><code>阅尽残篇断简，细评千古英雄。功名富贵笑谈中，回首一场春梦。
昨日香车宝马，今朝禾黍秋风。谁强谁弱总成空，傀儡棚中搬弄。
</code></pre>
<h2 id="第三段-说秦汉"><a href="#第三段-说秦汉" class="headerlink" title="第三段 说秦汉"></a>第三段 说秦汉</h2><h3 id="临江仙"><a href="#临江仙" class="headerlink" title="临江仙"></a>临江仙</h3><pre><code>滚滚长江东逝水，浪花淘尽英雄。是非成败转头空。青山依旧在，几度夕阳红。
白发渔樵江渚上，惯看秋月春风。一壶浊酒喜相逢。古今多少事，都付笑谈中。
</code></pre>
<h3 id="西江月-3"><a href="#西江月-3" class="headerlink" title="西江月"></a>西江月</h3><pre><code>落日西飞滚滚，大江东去滔滔。夜来今日又明朝，蓦地青春过了。
千古风流人物，一时多少英豪。龙争虎斗漫劬劳，落得一场谈笑。
</code></pre>
<h2 id="第四段-说三分两晋"><a href="#第四段-说三分两晋" class="headerlink" title="第四段 说三分两晋"></a>第四段 说三分两晋</h2><h3 id="西江月-4"><a href="#西江月-4" class="headerlink" title="西江月"></a>西江月</h3><pre><code>道德三皇五帝，功名夏后商周。英雄五伯闹春秋，秦汉兴亡过手。
青史几行名姓，北邙无数荒丘。前人田地后人收，说甚龙争虎斗。
</code></pre>
<h3 id="西江月-5"><a href="#西江月-5" class="headerlink" title="西江月"></a>西江月</h3><pre><code>豪杰千年往事，渔樵一曲高歌。乌飞兔走疾如梭，眨眼风惊雨过。
妙笔龙韬虎略，英雄铁马金戈。争名夺利竟如何，必有收因结果。
</code></pre>
<h2 id="第五段-说南北史"><a href="#第五段-说南北史" class="headerlink" title="第五段 说南北史"></a>第五段 说南北史</h2><h3 id="清平乐"><a href="#清平乐" class="headerlink" title="清平乐"></a>清平乐</h3><pre><code>闲行间坐，不必争人我。百岁光阴弹指过，成得什么功果。
昨日羯鼓催花，今朝疏柳啼鸦。王谢堂前燕子，不知飞入谁家。
</code></pre>
<h3 id="西江月-6"><a href="#西江月-6" class="headerlink" title="西江月"></a>西江月</h3><pre><code>飒飒西风渭水，萧萧落叶长安。英雄回首北邙山，虎斗龙争过眼。
闲看坝桥杨柳，凄凉露冷风寒。断蝉声里凭阑干，不觉斜阳又晚。
</code></pre>
<h2 id="第六段-说五胡"><a href="#第六段-说五胡" class="headerlink" title="第六段 说五胡"></a>第六段 说五胡</h2><h3 id="点绛唇"><a href="#点绛唇" class="headerlink" title="点绛唇"></a>点绛唇</h3><pre><code>暮鼓晨钟。春花秋月何时了，七颠八倒，往事知多少。
昨日今朝，镜里容颜老。千年调，一场谈笑，几个人知道。
</code></pre>
<h3 id="西江月-7"><a href="#西江月-7" class="headerlink" title="西江月"></a>西江月</h3><pre><code>六代瓜分世界，五胡云扰中原。纵横三百有馀年，几度交锋索战。
马过生灵齑粉，血流河洛腥膻。耳闻犹自不堪言，有眼休教看见。
</code></pre>
<h2 id="第七段-说隋唐"><a href="#第七段-说隋唐" class="headerlink" title="第七段 说隋唐"></a>第七段 说隋唐</h2><h3 id="临江仙-1"><a href="#临江仙-1" class="headerlink" title="临江仙"></a>临江仙</h3><pre><code>一片残山并剩水，年年虎斗龙争。秦宫汉苑晋家茔，川源流恨血，毛发凛威灵。
白发诗人闲驻马，感时怀古伤情。战场田地好宽平，前人将不去，留与后人耕。
</code></pre>
<h3 id="西江月-8"><a href="#西江月-8" class="headerlink" title="西江月"></a>西江月</h3><pre><code>追想千年往事，六朝踪迹茫然。隋唐相继统中原，世态几回云变。
杨柳凄迷汴水，丹青惨淡凌烟。乐游原上草连天，飞起寒鸦一片。
</code></pre>
<h2 id="第八段-说五代"><a href="#第八段-说五代" class="headerlink" title="第八段 说五代"></a>第八段 说五代</h2><h3 id="定风波"><a href="#定风波" class="headerlink" title="定风波"></a>定风波</h3><pre><code>雨汗淋漓赴选场，秀才落得甚干忙。白发渔樵诸事懒，萧散。闲谈今古论兴亡。
虞夏商周秦楚汉，三分南北至隋唐。看到史官褒贬处，得避。不摇纨扇自然凉。
</code></pre>
<h3 id="西江月-9"><a href="#西江月-9" class="headerlink" title="西江月"></a>西江月</h3><pre><code>千古伤心旧事，一场谈笑春风。残篇断简记英雄，总为功名引动。
个个轰轰烈烈，人人扰扰匆匆。荣华富贵转头空，恰似南柯一梦。
</code></pre>
<h2 id="第九段-说宋辽金夏"><a href="#第九段-说宋辽金夏" class="headerlink" title="第九段 说宋辽金夏"></a>第九段 说宋辽金夏</h2><h3 id="蝶恋花"><a href="#蝶恋花" class="headerlink" title="蝶恋花"></a>蝶恋花</h3><pre><code>简尽残编并断简，细数兴亡。总是英雄汉，物有无常人有限。到头落得空长叹。
富贵荣华春过眼，汉主长陵，霸王乌江岸。早悟夜筵终有散，当初赌甚英雄汉。
</code></pre>
<h3 id="西江月-10"><a href="#西江月-10" class="headerlink" title="西江月"></a>西江月</h3><pre><code>三百馀年宋史，辽金西夏纵横。争强赌胜弄刀兵，谁解倒悬民命。
富贵草梢零露，英雄水上浮萍。是非成败总虚名，一枕南柯梦醒。
</code></pre>
<h2 id="第十段-说元"><a href="#第十段-说元" class="headerlink" title="第十段 说元"></a>第十段 说元</h2><h3 id="西江月-11"><a href="#西江月-11" class="headerlink" title="西江月"></a>西江月</h3><pre><code>山色消磨今古，水声流尽年光。翻云覆雨数兴亡，回首一般模样。
清景好天良夜，赏心春暖花香。百年身世细思量，不及樽前席上。
</code></pre>
<h3 id="西江月-12"><a href="#西江月-12" class="headerlink" title="西江月"></a>西江月</h3><pre><code>细思三皇五帝，一般锦绣江山，风调雨顺万民安，不见许多公案。
后世依他样子，齐家治国何难。流芳百世在人间，万古称扬赞叹。
</code></pre>
]]></content>
      <categories>
        <category>寻章摘句</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title>JS-collection</title>
    <url>/2021/01/02/JS-collection/</url>
    <content><![CDATA[<p>个人的 JS 知识点拾遗补阙笔记</p>
<p>来源：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93YW5nZG9jLmNvbS9qYXZhc2NyaXB0L2luZGV4Lmh0bWw=">JavaScript 教程 —— 阮一峰<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dhbmdkb2MvamF2YXNjcmlwdC10dXRvcmlhbA==">Github 地址<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<span id="more"></span>

<ul>
<li><a href="#%E6%A0%87%E7%AD%BElabel">标签（label）</a></li>
<li><a href="#%E7%A1%AE%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%80%BC%E6%98%AF%E4%BB%80%E4%B9%88%E7%B1%BB%E5%9E%8B">确定一个值是什么类型</a></li>
<li><a href="#%E6%95%B0%E5%80%BC">数值</a><ul>
<li><a href="#%E6%95%B0%E5%80%BC%E7%B2%BE%E5%BA%A6">数值精度</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E5%80%BC%E8%8C%83%E5%9B%B4">数值范围</a><ul>
<li><a href="#%E6%95%B0%E5%80%BC%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%B3%95">数值的表示法</a></li>
<li><a href="#nan">NaN</a></li>
</ul>
</li>
<li><a href="#%E5%AD%97%E7%AC%A6%E9%9B%86">字符集</a></li>
<li><a href="#%E5%AF%B9%E8%B1%A1">对象</a></li>
<li><a href="#%E5%87%BD%E6%95%B0">函数</a><ul>
<li><a href="#%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87">函数提升</a></li>
<li><a href="#%E4%BD%9C%E7%94%A8%E5%9F%9F">作用域</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E7%BB%84">数组</a></li>
<li><a href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6">算术运算符</a><ul>
<li><a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%9B%B8%E5%8A%A0">对象的相加</a></li>
<li><a href="#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6">比较运算符</a></li>
</ul>
</li>
<li><a href="#%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97%E7%AC%A6">布尔运算符</a></li>
<li><a href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6">二进制位运算符</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2">数据类型的转换</a><ul>
<li><a href="#trycatchfinally">try…catch…finally</a></li>
</ul>
</li>
<li><a href="#console-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E6%8E%A7%E5%88%B6%E5%8F%B0">console 对象与控制台</a><ul>
<li><a href="#consoletable">console.table()</a></li>
<li><a href="#consolecount">console.count()</a></li>
<li><a href="#consoledirconsoledirxml">console.dir()，console.dirxml()</a></li>
<li><a href="#consoleassert">console.assert()</a></li>
<li><a href="#consoletimeconsoletimeend">console.time()，console.timeEnd()</a></li>
<li><a href="#consolegroupconsolegroupendconsolegroupcollapsed">console.group()，console.groupEnd()，console.groupCollapsed()</a></li>
<li><a href="#consoletraceconsoleclear">console.trace()，console.clear()</a></li>
</ul>
</li>
<li><a href="#object-%E5%AF%B9%E8%B1%A1">Object 对象</a><ul>
<li><a href="#objectkeysobjectgetownpropertynames">Object.keys()，Object.getOwnPropertyNames()</a></li>
</ul>
</li>
<li><a href="#%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E5%AF%B9%E8%B1%A1">属性描述对象</a></li>
<li><a href="#%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E4%B8%8E-new-%E5%91%BD%E4%BB%A4">实例对象与 new 命令</a><ul>
<li><a href="#new-%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86">new 命令的原理</a></li>
<li><a href="#newtarget">new.target</a></li>
<li><a href="#objectcreate-%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1">Object.create() 创建实例对象</a></li>
</ul>
</li>
<li><a href="#this-%E5%85%B3%E9%94%AE%E5%AD%97">this 关键字</a><ul>
<li><a href="#%E7%BB%91%E5%AE%9A-this-%E7%9A%84%E6%96%B9%E6%B3%95">绑定 this 的方法</a></li>
<li><a href="#functionprototypecall">Function.prototype.call()</a></li>
<li><a href="#functionprototypeapply">Function.prototype.apply()</a></li>
<li><a href="#functionprototypebind">Function.prototype.bind()</a></li>
</ul>
</li>
<li><a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%A7%E6%89%BF">对象的继承</a><ul>
<li><a href="#instanceof-%E8%BF%90%E7%AE%97%E7%AC%A6">instanceof 运算符</a></li>
<li><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%A7%E6%89%BF">构造函数的继承</a></li>
<li><a href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF">多重继承</a></li>
</ul>
</li>
<li><a href="#object-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95">Object 对象的相关方法</a><ul>
<li><a href="#objectgetprototypeof">Object.getPrototypeOf()</a></li>
<li><a href="#objectsetprototypeof">Object.setPrototypeOf()</a></li>
<li><a href="#objectcreate">Object.create()</a></li>
<li><a href="#objectprototypeisprototypeof">Object.prototype.isPrototypeOf()</a></li>
<li><a href="#objectprototype__proto__">Object.prototype.__proto__</a></li>
<li><a href="#%E8%8E%B7%E5%8F%96%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83">获取原型对象方法的比较</a></li>
<li><a href="#objectgetownpropertynames">Object.getOwnPropertyNames()</a></li>
<li><a href="#objectprototypehasownproperty">Object.prototype.hasOwnProperty()</a></li>
</ul>
</li>
<li><a href="#in-%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C-forin-%E5%BE%AA%E7%8E%AF">in 运算符和 for…in 循环</a><ul>
<li><a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%B7%E8%B4%9D">对象的拷贝</a></li>
</ul>
</li>
</ul>
<h2 id="标签（label）"><a href="#标签（label）" class="headerlink" title="标签（label）"></a><span class="exturl" data-url="aHR0cHM6Ly93YW5nZG9jLmNvbS9qYXZhc2NyaXB0L2Jhc2ljL2dyYW1tYXIuaHRtbCMlRTYlQTAlODclRTclQUQlQkUlRUYlQkMlODhsYWJlbCVFRiVCQyU4OQ==">标签（label）<i class="fa fa-external-link-alt"></i></span></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 标签通常与 `break` 语句和 `continue` 语句配合使用，跳出特定的循环。</span></span><br><span class="line"><span class="attr">top</span>:</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (i === <span class="number">1</span> &amp;&amp; j === <span class="number">1</span>) <span class="keyword">break</span> top;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;i=&#x27;</span> + i + <span class="string">&#x27;, j=&#x27;</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// i=0, j=0</span></span><br><span class="line"><span class="comment">// i=0, j=1</span></span><br><span class="line"><span class="comment">// i=0, j=2</span></span><br><span class="line"><span class="comment">// i=1, j=0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 标签也可以用于跳出代码块。</span></span><br><span class="line"><span class="attr">foo</span>: &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">break</span> foo;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;本行不会输出&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h2 id="确定一个值是什么类型"><a href="#确定一个值是什么类型" class="headerlink" title="确定一个值是什么类型"></a>确定一个值是什么类型</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. typeof https://wangdoc.com/javascript/types/general.html#typeof-%E8%BF%90%E7%AE%97%E7%AC%A6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">123</span> <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;123&#x27;</span> <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">false</span> <span class="comment">// &quot;boolean&quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">typeof</span> f <span class="comment">// &quot;function&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="variable language_">window</span> <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// &quot;object&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. instanceof</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Object.prototype.toString</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">2</span>) <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">true</span>) <span class="comment">// &quot;[object Boolean]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">undefined</span>) <span class="comment">// &quot;[object Undefined]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>) <span class="comment">// &quot;[object Null]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="title class_">Math</span>) <span class="comment">// &quot;[object Math]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123;&#125;) <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([]) <span class="comment">// &quot;[object Array]&quot;</span></span><br><span class="line"><span class="keyword">var</span> type = <span class="keyword">function</span> (<span class="params">o</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> s = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(o);</span><br><span class="line">  <span class="keyword">return</span> s.<span class="title function_">match</span>(<span class="regexp">/\[object (.*?)\]/</span>)[<span class="number">1</span>].<span class="title function_">toLowerCase</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">type</span>(&#123;&#125;); <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="title function_">type</span>([]); <span class="comment">// &quot;array&quot;</span></span><br><span class="line"><span class="title function_">type</span>(<span class="number">5</span>); <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="title function_">type</span>(<span class="literal">null</span>); <span class="comment">// &quot;null&quot;</span></span><br><span class="line"><span class="title function_">type</span>(); <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="title function_">type</span>(<span class="regexp">/abcd/</span>); <span class="comment">// &quot;regex&quot;</span></span><br><span class="line"><span class="title function_">type</span>(<span class="keyword">new</span> <span class="title class_">Date</span>()); <span class="comment">// &quot;date&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="数值"><a href="#数值" class="headerlink" title="数值"></a><span class="exturl" data-url="aHR0cHM6Ly93YW5nZG9jLmNvbS9qYXZhc2NyaXB0L3R5cGVzL251bWJlci5odG1s">数值<i class="fa fa-external-link-alt"></i></span></h2><ol>
<li><p>JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时 JavaScript 会自动把64位浮点数，转成32位整数，然后再进行运算。</p>
</li>
<li><p>根据国际标准 IEEE 754，JavaScript 浮点数的64个二进制位，从最左边开始，是这样组成的。</p>
</li>
</ol>
<ul>
<li>第1位：符号位，0表示正数，1表示负数</li>
<li>第2位到第12位（共11位）：指数部分</li>
<li>第13位到第64位（共52位）：小数部分（即有效数字）</li>
</ul>
<p>符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。</p>
<h3 id="数值精度"><a href="#数值精度" class="headerlink" title="数值精度"></a>数值精度</h3><p>指数部分一共有11个二进制位，因此大小范围就是0到2047。IEEE 754 规定，如果指数部分的值在0到2047之间（不含两个端点），那么有效数字的第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字这时总是1.xx…xx的形式，其中xx..xx的部分保存在64位浮点数之中，最长可能为52位。因此，JavaScript 提供的有效数字最长为53个二进制位。</p>
<p><code>(-1)^符号位 * 1.xx...xx * 2^指数部分</code></p>
<p>上面公式是正常情况下（指数部分在0到2047之间），一个数在 JavaScript 内部实际的表示形式。</p>
<p>精度最多只能到53个二进制位，这意味着，绝对值小于2的53次方的整数，即-253到253，都可以精确表示。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">53</span>)</span><br><span class="line"><span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span></span><br><span class="line"><span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">2</span></span><br><span class="line"><span class="comment">// 9007199254740994</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">3</span></span><br><span class="line"><span class="comment">// 9007199254740996</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">4</span></span><br><span class="line"><span class="comment">// 9007199254740996</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，大于2的53次方以后，整数运算的结果开始出现错误。所以，大于2的53次方的数值，都无法保持精度。由于2的53次方是一个16位的十进制数值，所以简单的法则就是，JavaScript 对15位的十进制数都可以精确处理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">53</span>)</span><br><span class="line"><span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多出的三个有效数字，将无法保存</span></span><br><span class="line"><span class="number">9007199254740992111</span></span><br><span class="line"><span class="comment">// 9007199254740992000</span></span><br></pre></td></tr></table></figure>

<p>上面示例表明，大于2的53次方以后，多出来的有效数字（最后三位的111）都会无法保存，变成0。</p>
<h2 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h2><p>根据标准，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则 JavaScript 能够表示的数值范围为21024到2-1023（开区间），超出这个范围的数无法表示。</p>
<p>如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回<code>Infinity</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">1024</span>) <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure>

<p>如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回0。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, -<span class="number">1075</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>JavaScript 提供<code>Number</code>对象的<code>MAX_VALUE</code>和<code>MIN_VALUE</code>属性，返回可以表示的具体的最大值和最小值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="property">MAX_VALUE</span> <span class="comment">// 1.7976931348623157e+308</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="property">MIN_VALUE</span> <span class="comment">// 5e-324</span></span><br></pre></td></tr></table></figure>

<h3 id="数值的表示法"><a href="#数值的表示法" class="headerlink" title="数值的表示法"></a>数值的表示法</h3><p>avaScript 的数值有多种表示方法，可以用字面形式直接表示，比如35（十进制）和0xFF（十六进制）。</p>
<p>数值也可以采用科学计数法表示，下面是几个科学计数法的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">123e3</span> <span class="comment">// 123000</span></span><br><span class="line"><span class="number">123e-3</span> <span class="comment">// 0.123</span></span><br><span class="line">-<span class="number">3.1E+12</span></span><br><span class="line"><span class="number">.1e-23</span></span><br></pre></td></tr></table></figure>

<p>科学计数法允许字母<code>e</code>或<code>E</code>的后面，跟着一个整数，表示这个数值的指数部分。</p>
<p>以下两种情况，JavaScript 会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。</p>
<p>（1）小数点前的数字多于21位。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1234567890123456789012</span></span><br><span class="line"><span class="comment">// 1.2345678901234568e+21</span></span><br><span class="line"></span><br><span class="line"><span class="number">123456789012345678901</span></span><br><span class="line"><span class="comment">// 123456789012345680000</span></span><br></pre></td></tr></table></figure>

<p>（2）小数点后的零多于5个。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 小数点后紧跟5个以上的零，</span></span><br><span class="line"><span class="comment">// 就自动转为科学计数法</span></span><br><span class="line"><span class="number">0.0000003</span> <span class="comment">// 3e-7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 否则，就保持原来的字面形式</span></span><br><span class="line"><span class="number">0.000003</span> <span class="comment">// 0.000003</span></span><br></pre></td></tr></table></figure>

<h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><p><code>isNaN</code>方法可以用来判断一个值是否为<code>NaN</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="title class_">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">123</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>但是，<code>isNaN</code>只对数值有效，如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成<code>NaN</code>，所以最后返回<code>true</code>，这一点要特别引起注意。也就是说，<code>isNaN</code>为<code>true</code>的值，有可能不是<code>NaN</code>，而是一个字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="title class_">Number</span>(<span class="string">&#x27;Hello&#x27;</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>出于同样的原因，对于对象和数组，<code>isNaN</code>也返回<code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(&#123;&#125;) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="title class_">Number</span>(&#123;&#125;)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isNaN</span>([<span class="string">&#x27;xzy&#x27;</span>]) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="title class_">Number</span>([<span class="string">&#x27;xzy&#x27;</span>])) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>但是，对于空数组和只有一个数值成员的数组，<code>isNaN</code>返回<code>false</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>([]) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>([<span class="number">123</span>]) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>([<span class="string">&#x27;123&#x27;</span>]) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码之所以返回<code>false</code>，原因是这些数组能被<code>Number</code>函数转成数值，请参见《数据类型转换》一章。</p>
<p>因此使用<code>isNaN</code>之前，最好判断一下数据类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myIsNaN</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">&#x27;number&#x27;</span> &amp;&amp; <span class="built_in">isNaN</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断<code>NaN</code>更可靠的方法是，利用<code>NaN</code>为唯一不等于自身的值的这个特点，进行判断。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myIsNaN</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> value !== value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>笔者注：使用 <code>Number.isNaN</code> 可避免上述问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(&#123;&#125;) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>([<span class="string">&#x27;xzy&#x27;</span>]) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a><span class="exturl" data-url="aHR0cHM6Ly93YW5nZG9jLmNvbS9qYXZhc2NyaXB0L3R5cGVzL3N0cmluZy5odG1sIyVFNSVBRCU5NyVFNyVBQyVBNiVFOSU5QiU4Ng==">字符集<i class="fa fa-external-link-alt"></i></span></h2><p>JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。</p>
<p>JavaScript 不仅以 Unicode 储存字符，还允许直接在程序中使用 Unicode 码点表示字符，即将字符写成<code>\uxxxx</code>的形式，其中<code>xxxx</code>代表该字符的 Unicode 码点。比如，<code>\u00A9</code>代表版权符号。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;\u00A9&#x27;</span>;</span><br><span class="line">s <span class="comment">// &quot;©&quot;</span></span><br></pre></td></tr></table></figure>

<p>解析代码的时候，JavaScript 会自动识别一个字符是字面形式表示，还是 Unicode 形式表示。输出给用户的时候，所有字符都会转成字面形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f\u006F\u006F = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">foo <span class="comment">// &quot;abc&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，第一行的变量名<code>foo</code>是 Unicode 形式表示，第二行是字面形式表示。JavaScript 会自动识别。</p>
<p>我们还需要知道，每个字符在 JavaScript 内部都是以16位（即2个字节）的 UTF-16 格式储存。也就是说，JavaScript 的单位字符长度固定为16位长度，即2个字节。</p>
<p>但是，UTF-16 有两种长度：对于码点在<code>U+0000</code>到<code>U+FFFF</code>之间的字符，长度为16位（即2个字节）；对于码点在<code>U+10000</code>到<code>U+10FFFF</code>之间的字符，长度为32位（即4个字节），而且前两个字节在<code>0xD800</code>到<code>0xDBFF</code>之间，后两个字节在<code>0xDC00</code>到<code>0xDFFF</code>之间。举例来说，码点<code>U+1D306</code>对应的字符为<code>𝌆</code>，它写成 UTF-16 就是<code>0xD834 0xDF06</code>。</p>
<p>JavaScript 对 UTF-16 的支持是不完整的，由于历史原因，只支持两字节的字符，不支持四字节的字符。这是因为 JavaScript 第一版发布的时候，Unicode 的码点只编到<code>U+FFFF</code>，因此两字节足够表示了。后来，Unicode 纳入的字符越来越多，出现了四字节的编码。但是，JavaScript 的标准此时已经定型了，统一将字符长度限制在两字节，导致无法识别四字节的字符。上一节的那个四字节字符<code>𝌆</code>，浏览器会正确识别这是一个字符，但是 JavaScript 无法识别，会认为这是两个字符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;𝌆&#x27;</span>.<span class="property">length</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，JavaScript 认为<code>𝌆</code>的长度为2，而不是1。</p>
<p>总结一下，对于码点在<code>U+10000</code>到<code>U+10FFFF</code>之间的字符，JavaScript 总是认为它们是两个字符（<code>length</code>属性为2）。所以处理的时候，必须把这一点考虑在内，也就是说，JavaScript 返回的字符串长度可能是不正确的。</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a><span class="exturl" data-url="aHR0cHM6Ly93YW5nZG9jLmNvbS9qYXZhc2NyaXB0L3R5cGVzL29iamVjdC5odG1s">对象<i class="fa fa-external-link-alt"></i></span></h2><ol>
<li>查看一个对象本身的所有属性，可以使用<code>Object.keys</code>方法。</li>
<li><code>delete</code>命令只能删除对象本身的属性，无法删除继承的属性。</li>
<li><code>in</code>运算符用于检查对象是否包含某个属性，它不能识别哪些属性是对象自身的，哪些属性是继承的。可以使用对象的<code>hasOwnProperty</code>方法判断一下，是否为对象自身的属性。</li>
<li><code>for...in</code> 循环用来遍历一个对象的全部属性。它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。它不仅遍历对象自身的属性，还遍历继承的属性。</li>
<li><code>with</code> 语句。它的作用是操作同一个对象的多个属性时，提供一些书写的方便。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">p1</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">p2</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">with</span> (obj) &#123;</span><br><span class="line">  p1 = <span class="number">4</span>;</span><br><span class="line">  p2 = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">obj.<span class="property">p1</span> = <span class="number">4</span>;</span><br><span class="line">obj.<span class="property">p2</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">with</span> (<span class="variable language_">document</span>.<span class="property">links</span>[<span class="number">0</span>])&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(href);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(title);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(style);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">links</span>[<span class="number">0</span>].<span class="property">href</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">links</span>[<span class="number">0</span>].<span class="property">title</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">links</span>[<span class="number">0</span>].<span class="property">style</span>);</span><br></pre></td></tr></table></figure>

<p>注意，如果<code>with</code>区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">with</span> (obj) &#123;</span><br><span class="line">  p1 = <span class="number">4</span>;</span><br><span class="line">  p2 = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">p1</span> <span class="comment">// undefined</span></span><br><span class="line">p1 <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>obj</code>并没有<code>p1</code>属性，对<code>p1</code>赋值等于创造了一个全局变量<code>p1</code>。正确的写法应该是，先定义对象<code>obj</code>的属性<code>p1</code>，然后在<code>with</code>区块内操作它。</p>
<p>这是因为<code>with</code>区块没有改变作用域，它的内部依然是当前作用域。这造成了<code>with</code>语句的一个很大的弊病，就是绑定对象不明确。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> (obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单纯从上面的代码块，根本无法判断<code>x</code>到底是全局变量，还是对象<code>obj</code>的一个属性。这非常不利于代码的除错和模块化，编译器也无法对这段代码进行优化，只能留到运行时判断，这就拖慢了运行速度。因此，建议不要使用<code>with</code>语句，可以考虑用一个临时变量代替<code>with</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">with</span>(<span class="params">obj1.obj2.obj3</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(p1 + p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以写成</span></span><br><span class="line"><span class="keyword">var</span> temp = obj1.<span class="property">obj2</span>.<span class="property">obj3</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(temp.<span class="property">p1</span> + temp.<span class="property">p2</span>);</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a><span class="exturl" data-url="aHR0cHM6Ly93YW5nZG9jLmNvbS9qYXZhc2NyaXB0L3R5cGVzL2Z1bmN0aW9uLmh0bWw=">函数<i class="fa fa-external-link-alt"></i></span></h2><h3 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h3><p>注意，如果像下面例子那样，采用<code>function</code>命令和<code>var</code>赋值语句声明同一个函数，由于存在函数提升，最后会采用<code>var</code>赋值语句的定义。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面例子中，表面上后面声明的函数<code>f</code>，应该覆盖前面的<code>var</code>赋值语句，但是由于存在函数提升，实际上正好反过来。</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>ES5 的规范中，JavaScript 只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在</p>
<p>函数内部的变量提升。与全局作用域一样，函数作用域内部也会产生“变量提升”现象。<code>var</code>命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = x - <span class="number">100</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> tmp;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    tmp = x - <span class="number">100</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数本身的作用域。函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="title function_">x</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>x</code>是在函数<code>f</code>的外部声明的，所以它的作用域绑定外层，内部变量<code>a</code>不会到函数<code>f</code>体内取值，所以输出<code>1</code>，而不是<code>2</code>。</p>
<p>总之，函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。</p>
<p>很容易犯错的一点是，如果函数<code>A</code>调用函数<code>B</code>，却没考虑到函数<code>B</code>不会引用函数<code>A</code>的内部变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">y</span>(<span class="params">f</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="title function_">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">y</span>(x)</span><br><span class="line"><span class="comment">// ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>

<p>上面代码将函数<code>x</code>作为参数，传入函数<code>y</code>。但是，函数<code>x</code>是在函数<code>y</code>体外声明的，作用域绑定外层，因此找不到函数<code>y</code>的内部变量<code>a</code>，导致报错。</p>
<p>同样的，函数体内部声明的函数，作用域绑定函数体内部。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> f = <span class="title function_">foo</span>();</span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>foo</code>内部声明了一个函数<code>bar，bar</code>的作用域绑定<code>foo</code>。当我们在<code>foo</code>外部取出<code>bar</code>执行时，变量<code>x</code>指向的是<code>foo</code>内部的<code>x</code>，而不是<code>foo</code>外部的<code>x</code>。正是这种机制，构成了下文要讲解的“闭包”现象。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a><span class="exturl" data-url="aHR0cHM6Ly93YW5nZG9jLmNvbS9qYXZhc2NyaXB0L3R5cGVzL2FycmF5Lmh0bWw=">数组<i class="fa fa-external-link-alt"></i></span></h2><p>JavaScript 使用一个32位整数，保存数组的元素个数。这意味着，数组成员最多只有 4294967295 个（232 - 1）个，也就是说<code>length</code>属性的最大值就是 4294967295。</p>
<p>数组的某个位置是空位，与某个位置是<code>undefined</code>，是不一样的。如果是空位，使用数组的<code>forEach</code>方法、<code>for...in</code>结构、以及<code>Object.keys</code>方法进行遍历，空位都会被跳过。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [, , ,];</span><br><span class="line"></span><br><span class="line">a.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">x, i</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i + <span class="string">&#x27;. &#x27;</span> + x);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 不产生任何输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不产生任何输出</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(a)</span><br><span class="line"><span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<p>如果某个位置是<code>undefined</code>，遍历的时候就不会被跳过。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>];</span><br><span class="line"></span><br><span class="line">a.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">x, i</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i + <span class="string">&#x27;. &#x27;</span> + x);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 0. undefined</span></span><br><span class="line"><span class="comment">// 1. undefined</span></span><br><span class="line"><span class="comment">// 2. undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(a)</span><br><span class="line"><span class="comment">// [&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>这就是说，空位就是数组没有这个元素，所以不会被遍历到，而<code>undefined</code>则表示数组有这个元素，值是<code>undefined</code>，所以遍历不会跳过。</p>
<p>数组的<code>slice</code>方法可以将“类似数组的对象”变成真正的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(arrayLike);</span><br></pre></td></tr></table></figure>

<p>除了转为真正的数组，“类似数组的对象”还有一个办法可以使用数组的方法，就是通过<code>call()</code>把数组的方法放到对象上面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">print</span>(<span class="params">value, index</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(index + <span class="string">&#x27; : &#x27;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">forEach</span>.<span class="title function_">call</span>(arrayLike, print);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>arrayLike</code>代表一个类似数组的对象，本来是不可以使用数组的<code>forEach()</code>方法的，但是通过<code>call()</code>，可以把<code>forEach()</code>嫁接到<code>arrayLike</code>上面调用。</p>
<p>下面的例子就是通过这种方法，在<code>arguments</code>对象上面调用<code>forEach</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// forEach 方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logArgs</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">forEach</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="keyword">function</span> (<span class="params">elem, i</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i + <span class="string">&#x27;. &#x27;</span> + elem);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 for 循环</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logArgs</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i + <span class="string">&#x27;. &#x27;</span> + <span class="variable language_">arguments</span>[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符串也是类似数组的对象，所以也可以用<code>Array.prototype.forEach.call</code>遍历。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">forEach</span>.<span class="title function_">call</span>(<span class="string">&#x27;abc&#x27;</span>, <span class="keyword">function</span> (<span class="params">chr</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(chr);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br></pre></td></tr></table></figure>

<p>注意，这种方法比直接使用数组原生的<code>forEach</code>要慢，所以最好还是先将“类似数组的对象”转为真正的数组，然后再直接调用数组的<code>forEach</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">chr</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(chr);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br></pre></td></tr></table></figure>

<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a><span class="exturl" data-url="aHR0cHM6Ly93YW5nZG9jLmNvbS9qYXZhc2NyaXB0L29wZXJhdG9ycy9hcml0aG1ldGljLmh0bWw=">算术运算符<i class="fa fa-external-link-alt"></i></span></h2><h3 id="对象的相加"><a href="#对象的相加" class="headerlink" title="对象的相加"></a>对象的相加</h3><p>如果运算子是对象，必须先转成原始类型的值，然后再相加。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line">obj + <span class="number">2</span> <span class="comment">// &quot;[object Object]2&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>obj</code>转成原始类型的值是<code>[object Object]</code>，再加<code>2</code>就得到了上面的结果。</p>
<p>对象转成原始类型的值，规则如下。</p>
<p>首先，自动调用对象的<code>valueOf</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line">obj.<span class="title function_">valueOf</span>() <span class="comment">// &#123; p: 1 &#125;</span></span><br></pre></td></tr></table></figure>

<p>一般来说，对象的<code>valueOf</code>方法总是返回对象自身，这时再自动调用对象的<code>toString</code>方法，将其转为字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line">obj.<span class="title function_">valueOf</span>().<span class="title function_">toString</span>() <span class="comment">// &quot;[object Object]&quot;</span></span><br></pre></td></tr></table></figure>

<p>对象的<code>toString</code>方法默认返回<code>[object Object]</code>，所以就得到了最前面那个例子的结果。</p>
<p>知道了这个规则以后，就可以自己定义<code>valueOf</code>方法或<code>toString</code>方法，得到想要的结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">valueOf</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj + <span class="number">2</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，我们定义<code>obj</code>对象的<code>valueOf</code>方法返回<code>1</code>，于是<code>obj + 2</code>就得到了<code>3</code>。这个例子中，由于<code>valueOf</code>方法直接返回一个原始类型的值，所以不再调用<code>toString</code>方法。</p>
<p>下面是自定义<code>toString</code>方法的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">toString</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj + <span class="number">2</span> <span class="comment">// &quot;hello2&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>obj</code>的<code>toString</code>方法返回字符串<code>hello</code>。前面说过，只要有一个运算子是字符串，加法运算符就变成连接运算符，返回连接后的字符串。</p>
<p>这里有一个特例，如果运算子是一个<code>Date</code>对象的实例，那么会优先执行<code>toString</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">obj.<span class="property">valueOf</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;;</span><br><span class="line">obj.<span class="property">toString</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">obj + <span class="number">2</span> <span class="comment">// &quot;hello2&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>obj</code>是一个<code>Date</code>对象的实例，并且自定义了<code>valueOf</code>方法和<code>toString</code>方法，结果<code>toString</code>方法优先执行。</p>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a><span class="exturl" data-url="aHR0cHM6Ly93YW5nZG9jLmNvbS9qYXZhc2NyaXB0L29wZXJhdG9ycy9jb21wYXJpc29uLmh0bWw=">比较运算符<i class="fa fa-external-link-alt"></i></span></h3><p>这八个比较运算符分成两类：相等比较和非相等比较。两者的规则是不一样的，对于非相等的比较，算法是先看两个运算子是否都是字符串，如果是的，就按照字典顺序比较（实际上是比较 Unicode 码点）；否则，将两个运算子都转成数值，再比较数值的大小。</p>
<h2 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a><span class="exturl" data-url="aHR0cHM6Ly93YW5nZG9jLmNvbS9qYXZhc2NyaXB0L29wZXJhdG9ycy9ib29sZWFuLmh0bWw=">布尔运算符<i class="fa fa-external-link-alt"></i></span></h2><p>且运算符（<code>&amp;&amp;</code>）往往用于多个表达式的求值。</p>
<p>它的运算规则是：如果第一个运算子的布尔值为<code>true</code>，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为<code>false</code>，则直接返回第一个运算子的值，且不再对第二个运算子求值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;t&#x27;</span> &amp;&amp; <span class="string">&#x27;&#x27;</span> <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="string">&#x27;t&#x27;</span> &amp;&amp; <span class="string">&#x27;f&#x27;</span> <span class="comment">// &quot;f&quot;</span></span><br><span class="line"><span class="string">&#x27;t&#x27;</span> &amp;&amp; (<span class="number">1</span> + <span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> &amp;&amp; <span class="string">&#x27;f&#x27;</span> <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> &amp;&amp; <span class="string">&#x27;&#x27;</span> <span class="comment">// &quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">(<span class="number">1</span> - <span class="number">1</span>) &amp;&amp; ( x += <span class="number">1</span>) <span class="comment">// 0</span></span><br><span class="line">x <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码的最后一个例子，由于且运算符的第一个运算子的布尔值为<code>false</code>，则直接返回它的值<code>0</code>，而不再对第二个运算子求值，所以变量<code>x</code>的值没变。</p>
<p>这种跳过第二个运算子的机制，被称为“短路”。有些程序员喜欢用它取代<code>if</code>结构，比如下面是一段<code>if</code>结构的代码，就可以用且运算符改写。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i) &#123;</span><br><span class="line">  <span class="title function_">doSomething</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"></span><br><span class="line">i &amp;&amp; <span class="title function_">doSomething</span>();</span><br></pre></td></tr></table></figure>

<p>上面代码的两种写法是等价的，但是后一种不容易看出目的，也不容易除错，建议谨慎使用。</p>
<p>且运算符可以多个连用，这时返回第一个布尔值为<code>false</code>的表达式的值。如果所有表达式的布尔值都为<code>true</code>，则返回最后一个表达式的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span> &amp;&amp; <span class="string">&#x27;foo&#x27;</span> &amp;&amp; <span class="string">&#x27;&#x27;</span> &amp;&amp; <span class="number">4</span> &amp;&amp; <span class="string">&#x27;foo&#x27;</span> &amp;&amp; <span class="literal">true</span></span><br><span class="line"><span class="comment">// &#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &amp;&amp; <span class="number">2</span> &amp;&amp; <span class="number">3</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，例一里面，第一个布尔值为<code>false</code>的表达式为第三个表达式，所以得到一个空字符串。例二里面，所有表达式的布尔值都是<code>true</code>，所以返回最后一个表达式的值<code>3</code>。</p>
<h2 id="二进制位运算符"><a href="#二进制位运算符" class="headerlink" title="二进制位运算符"></a><span class="exturl" data-url="aHR0cHM6Ly93YW5nZG9jLmNvbS9qYXZhc2NyaXB0L29wZXJhdG9ycy9iaXQuaHRtbA==">二进制位运算符<i class="fa fa-external-link-alt"></i></span></h2><p>二进制位运算符用于直接对二进制位进行计算，一共有7个。</p>
<ul>
<li>二进制或运算符（or）：符号为<code>|</code>，表示若两个二进制位都为<code>0</code>，则结果为<code>0</code>，否则为<code>1</code>。</li>
<li>二进制与运算符（and）：符号为<code>&amp;</code>，表示若两个二进制位都为<code>1</code>，则结果为<code>1</code>，否则为<code>0</code>。</li>
<li>二进制否运算符（not）：符号为<code>~</code>，表示对一个二进制位取反。</li>
<li>异或运算符（xor）：符号为<code>^</code>，表示若两个二进制位不相同，则结果为<code>1</code>，否则为<code>0</code>。</li>
<li>左移运算符（left shift）：符号为<code>&lt;&lt;</code>，详见下文解释。</li>
<li>右移运算符（right shift）：符号为<code>&gt;&gt;</code>，详见下文解释。</li>
<li>头部补零的右移运算符（zero filled right shift）：符号为<code>&gt;&gt;&gt;</code>，详见下文解释。</li>
</ul>
<p>这些位运算符直接处理每一个比特位（bit），所以是非常底层的运算，好处是速度极快，缺点是很不直观，许多场合不能使用它们，否则会使代码难以理解和查错。</p>
<p>有一点需要特别注意，位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。另外，虽然在 JavaScript 内部，数值都是以64位浮点数的形式储存，但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">i = i | <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>上面这行代码的意思，就是将i（不管是整数或小数）转为32位整数。</p>
<p>利用这个特性，可以写出一个函数，将任意数值转为32位整数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toInt32</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x | <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个函数将任意值与0进行一次或运算，这个位运算会自动将一个值转为32位整数。下面是这个函数的用法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">toInt32</span>(<span class="number">1.001</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">toInt32</span>(<span class="number">1.999</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">toInt32</span>(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">toInt32</span>(-<span class="number">1</span>) <span class="comment">// -1</span></span><br><span class="line"><span class="title function_">toInt32</span>(<span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">32</span>) + <span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">toInt32</span>(<span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">32</span>) - <span class="number">1</span>) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>toInt32</code>可以将小数转为整数。对于一般的整数，返回值不会有任何变化。对于大于或等于2的32次方的整数，大于32位的数位都会被舍去。</p>
<p>对一个整数连续两次二进制否运算，得到它自身。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">~~<span class="number">3</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>所有的位运算都只对整数有效。二进制否运算遇到小数时，也会将小数部分舍去，只保留整数部分。所以，对一个小数连续进行两次二进制否运算，能达到取整效果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">~~<span class="number">2.9</span> <span class="comment">// 2</span></span><br><span class="line">~~<span class="number">47.11</span> <span class="comment">// 47</span></span><br><span class="line">~~<span class="number">1.9999</span> <span class="comment">// 1</span></span><br><span class="line">~~<span class="number">3</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>使用二进制否运算取整，是所有取整方法中最快的一种。</p>
<p>“异或运算”有一个特殊运用，连续对两个数<code>a</code>和<code>b</code>进行三次异或运算，<code>a^=b; b^=a; a^=b;</code>，可以互换它们的值。这意味着，使用“异或运算”可以在不引入临时变量的前提下，互换两个变量的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line">a ^= b, b ^= a, a ^= b;</span><br><span class="line"></span><br><span class="line">a <span class="comment">// 99</span></span><br><span class="line">b <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>这是互换两个变量的值的最快方法。</p>
<p>异或运算也可以用来取整。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">12.9</span> ^ <span class="number">0</span> <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>

<p>左移运算符。如果左移0位，就相当于将该数值转为32位整数，等同于取整，对于正数和负数都有效。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">13.5</span> &lt;&lt; <span class="number">0</span></span><br><span class="line"><span class="comment">// 13</span></span><br><span class="line"></span><br><span class="line">-<span class="number">13.5</span> &lt;&lt; <span class="number">0</span></span><br><span class="line"><span class="comment">// -13</span></span><br></pre></td></tr></table></figure>

<p>位运算符可以用作设置对象属性的开关。</p>
<p>假定某个对象有四个开关，每个开关都是一个变量。那么，可以设置一个四位的二进制数，它的每个位对应一个开关。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable constant_">FLAG_A</span> = <span class="number">1</span>; <span class="comment">// 0001</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">FLAG_B</span> = <span class="number">2</span>; <span class="comment">// 0010</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">FLAG_C</span> = <span class="number">4</span>; <span class="comment">// 0100</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">FLAG_D</span> = <span class="number">8</span>; <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure>

<p>上面代码设置 A、B、C、D 四个开关，每个开关分别占有一个二进制位。</p>
<p>然后，就可以用二进制与运算，检查当前设置是否打开了指定开关。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> flags = <span class="number">5</span>; <span class="comment">// 二进制的0101</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flags &amp; <span class="variable constant_">FLAG_C</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0101 &amp; 0100 =&gt; 0100 =&gt; true</span></span><br></pre></td></tr></table></figure>

<p>上面代码检验是否打开了开关C。如果打开，会返回<code>true</code>，否则返回<code>false</code>。</p>
<p>现在假设需要打开A、B、D三个开关，我们可以构造一个掩码变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mask = <span class="variable constant_">FLAG_A</span> | <span class="variable constant_">FLAG_B</span> | <span class="variable constant_">FLAG_D</span>;</span><br><span class="line"><span class="comment">// 0001 | 0010 | 1000 =&gt; 1011</span></span><br></pre></td></tr></table></figure>

<p>上面代码对A、B、D三个变量进行二进制或运算，得到掩码值为二进制的1011。</p>
<p>有了掩码，二进制或运算可以确保打开指定的开关。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">flags = flags | mask;</span><br></pre></td></tr></table></figure>

<p>上面代码中，计算后得到的flags变量，代表三个开关的二进制位都打开了。</p>
<p>二进制与运算可以将当前设置中凡是与开关设置不一样的项，全部关闭。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">flags = flags &amp; mask;</span><br></pre></td></tr></table></figure>

<p>异或运算可以切换（toggle）当前设置，即第一次执行可以得到当前设置的相反值，再执行一次又得到原来的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">flags = flags ^ mask;</span><br></pre></td></tr></table></figure>

<p>二进制否运算可以翻转当前设置，即原设置为<code>0</code>，运算后变为<code>1</code>；原设置为<code>1</code>，运算后变为<code>0</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">flags = ~flags;</span><br></pre></td></tr></table></figure>

<h2 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a><span class="exturl" data-url="aHR0cHM6Ly93YW5nZG9jLmNvbS9qYXZhc2NyaXB0L2ZlYXR1cmVzL2NvbnZlcnNpb24uaHRtbA==">数据类型的转换<i class="fa fa-external-link-alt"></i></span></h2><p><code>String</code>方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。<code>String</code>方法背后的转换规则，与<code>Number</code>方法基本相同，只是互换了<code>valueOf</code>方法和<code>toString</code>方法的执行顺序。</p>
<ol>
<li>先调用对象自身的<code>toString</code>方法。如果返回原始类型的值，则对该值使用<code>String</code>函数，不再进行以下步骤。</li>
<li>如果<code>toString</code>方法返回的是对象，再调用原对象的<code>valueOf</code>方法。如果<code>valueOf</code>方法返回原始类型的值，则对该值使用<code>String</code>函数，不再进行以下步骤。</li>
<li>如果<code>valueOf</code>方法返回的是对象，就报错。</li>
</ol>
<h3 id="try…catch…finally"><a href="#try…catch…finally" class="headerlink" title="try…catch…finally"></a>try…catch…finally</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;bug&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 这句原本会延迟到 finally 代码块结束再执行</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>); <span class="comment">// 不会运行</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 这句会覆盖掉前面那句 return</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>); <span class="comment">// 不会运行</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>); <span class="comment">// 不会运行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">f</span>();</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">result</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;出错了！&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捕捉到内部错误&#x27;</span>);</span><br><span class="line">    <span class="keyword">throw</span> e; <span class="comment">// 这句原本会等到finally结束再执行</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 直接返回</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title function_">f</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="comment">// 此处不会执行</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;caught outer &quot;bogus&quot;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  捕捉到内部错误</span></span><br></pre></td></tr></table></figure>

<h2 id="console-对象与控制台"><a href="#console-对象与控制台" class="headerlink" title="console 对象与控制台"></a><span class="exturl" data-url="aHR0cHM6Ly93YW5nZG9jLmNvbS9qYXZhc2NyaXB0L2ZlYXR1cmVzL2NvbnNvbGUuaHRtbA==">console 对象与控制台<i class="fa fa-external-link-alt"></i></span></h2><h3 id="console-table"><a href="#console-table" class="headerlink" title="console.table()"></a>console.table()</h3><p>对于某些复合类型的数据，<code>console.table</code>方法可以将其转为表格显示。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> languages = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;JavaScript&quot;</span>, <span class="attr">fileExtension</span>: <span class="string">&quot;.js&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;TypeScript&quot;</span>, <span class="attr">fileExtension</span>: <span class="string">&quot;.ts&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;CoffeeScript&quot;</span>, <span class="attr">fileExtension</span>: <span class="string">&quot;.coffee&quot;</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">table</span>(languages);</span><br></pre></td></tr></table></figure>

<p>上面代码的<code>language</code>变量，转为表格显示如下。</p>
<table>
<thead>
<tr>
<th>(index)</th>
<th>name</th>
<th>fileExtension</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>“JavaScript”</td>
<td>“.js”</td>
</tr>
<tr>
<td>1</td>
<td>“TypeScript”</td>
<td>“.ts”</td>
</tr>
<tr>
<td>2</td>
<td>“CoffeeScript”</td>
<td>“.coffee”</td>
</tr>
</tbody></table>
<h3 id="console-count"><a href="#console-count" class="headerlink" title="console.count()"></a>console.count()</h3><p><code>count</code>方法用于计数，输出它被调用了多少次。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">user</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">count</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;hi &#x27;</span> + user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">greet</span>(<span class="string">&#x27;bob&#x27;</span>)</span><br><span class="line"><span class="comment">//  : 1</span></span><br><span class="line"><span class="comment">// &quot;hi bob&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">greet</span>(<span class="string">&#x27;alice&#x27;</span>)</span><br><span class="line"><span class="comment">//  : 2</span></span><br><span class="line"><span class="comment">// &quot;hi alice&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">greet</span>(<span class="string">&#x27;bob&#x27;</span>)</span><br><span class="line"><span class="comment">//  : 3</span></span><br><span class="line"><span class="comment">// &quot;hi bob&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码每次调用<code>greet</code>函数，内部的<code>console.count</code>方法就输出执行次数。</p>
<p>该方法可以接受一个字符串作为参数，作为标签，对执行次数进行分类。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">user</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">count</span>(user);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;hi &quot;</span> + user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">greet</span>(<span class="string">&#x27;bob&#x27;</span>)</span><br><span class="line"><span class="comment">// bob: 1</span></span><br><span class="line"><span class="comment">// &quot;hi bob&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">greet</span>(<span class="string">&#x27;alice&#x27;</span>)</span><br><span class="line"><span class="comment">// alice: 1</span></span><br><span class="line"><span class="comment">// &quot;hi alice&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">greet</span>(<span class="string">&#x27;bob&#x27;</span>)</span><br><span class="line"><span class="comment">// bob: 2</span></span><br><span class="line"><span class="comment">// &quot;hi bob&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码根据参数的不同，显示<code>bob</code>执行了两次，<code>alice</code>执行了一次。</p>
<h3 id="console-dir-，console-dirxml"><a href="#console-dir-，console-dirxml" class="headerlink" title="console.dir()，console.dirxml()"></a>console.dir()，console.dirxml()</h3><p><code>dir</code>方法用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;<span class="attr">f1</span>: <span class="string">&#x27;foo&#x27;</span>, <span class="attr">f2</span>: <span class="string">&#x27;bar&#x27;</span>&#125;)</span><br><span class="line"><span class="comment">// Object &#123;f1: &quot;foo&quot;, f2: &quot;bar&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">dir</span>(&#123;<span class="attr">f1</span>: <span class="string">&#x27;foo&#x27;</span>, <span class="attr">f2</span>: <span class="string">&#x27;bar&#x27;</span>&#125;)</span><br><span class="line"><span class="comment">// Object</span></span><br><span class="line"><span class="comment">//   f1: &quot;foo&quot;</span></span><br><span class="line"><span class="comment">//   f2: &quot;bar&quot;</span></span><br><span class="line"><span class="comment">//   __proto__: Object</span></span><br></pre></td></tr></table></figure>

<p>上面代码显示<code>dir</code>方法的输出结果，比<code>log</code>方法更易读，信息也更丰富。</p>
<p>该方法对于输出 DOM 对象非常有用，因为会显示 DOM 对象的所有属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">dir</span>(<span class="variable language_">document</span>.<span class="property">body</span>)</span><br></pre></td></tr></table></figure>

<p>Node 环境之中，还可以指定以代码高亮的形式输出。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">dir</span>(obj, &#123;<span class="attr">colors</span>: <span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>dirxml方法主要用于以目录树的形式，显示 DOM 节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">dirxml</span>(<span class="variable language_">document</span>.<span class="property">body</span>)</span><br></pre></td></tr></table></figure>

<p>如果参数不是 DOM 节点，而是普通的 JavaScript 对象，console.dirxml等同于console.dir。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">dirxml</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">dir</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<h3 id="console-assert"><a href="#console-assert" class="headerlink" title="console.assert()"></a>console.assert()</h3><p><code>console.assert</code>方法主要用于程序运行过程中，进行条件判断，如果不满足条件，就显示一个错误，但不会中断程序执行。这样就相当于提示用户，内部状态不正确。</p>
<p>它接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会提示有错误，在控制台输出第二个参数，否则不会有任何结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">assert</span>(<span class="literal">false</span>, <span class="string">&#x27;判断条件不成立&#x27;</span>)</span><br><span class="line"><span class="comment">// Assertion failed: 判断条件不成立</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;判断条件不成立&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是一个例子，判断子节点的个数是否大于等于500。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">assert</span>(list.<span class="property">childNodes</span>.<span class="property">length</span> &lt; <span class="number">500</span>, <span class="string">&#x27;节点个数大于等于500&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>上面代码中，如果符合条件的节点小于500个，不会有任何输出；只有大于等于500时，才会在控制台提示错误，并且显示指定文本。</p>
<h3 id="console-time-，console-timeEnd"><a href="#console-time-，console-timeEnd" class="headerlink" title="console.time()，console.timeEnd()"></a>console.time()，console.timeEnd()</h3><p>这两个方法用于计时，可以算出一个操作所花费的准确时间。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&#x27;Array initialize&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array= <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1000000</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = array.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">  array[i] = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">timeEnd</span>(<span class="string">&#x27;Array initialize&#x27;</span>);</span><br><span class="line"><span class="comment">// Array initialize: 1914.481ms</span></span><br></pre></td></tr></table></figure>

<p><code>time</code>方法表示计时开始，<code>timeEnd</code>方法表示计时结束。它们的参数是计时器的名称。调用<code>timeEnd</code>方法之后，控制台会显示“计时器名称: 所耗费的时间”。</p>
<h3 id="console-group-，console-groupEnd-，console-groupCollapsed"><a href="#console-group-，console-groupEnd-，console-groupCollapsed" class="headerlink" title="console.group()，console.groupEnd()，console.groupCollapsed()"></a>console.group()，console.groupEnd()，console.groupCollapsed()</h3><p><code>console.group</code>和<code>console.groupEnd</code>这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠&#x2F;展开。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">group</span>(<span class="string">&#x27;一级分组&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;一级分组的内容&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">group</span>(<span class="string">&#x27;二级分组&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;二级分组的内容&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">groupEnd</span>(); <span class="comment">// 二级分组结束</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">groupEnd</span>(); <span class="comment">// 一级分组结束</span></span><br></pre></td></tr></table></figure>

<p>上面代码会将“二级分组”显示在“一级分组”内部，并且“一级分组”和“二级分组”前面都有一个折叠符号，可以用来折叠本级的内容。</p>
<p><code>console.groupCollapsed</code>方法与<code>console.group</code>方法很类似，唯一的区别是该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">groupCollapsed</span>(<span class="string">&#x27;Fetching Data&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Request Sent&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error: Server not responding (500)&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">groupEnd</span>();</span><br></pre></td></tr></table></figure>

<p>上面代码只显示一行”Fetching Data“，点击后才会展开，显示其中包含的两行。</p>
<h3 id="console-trace-，console-clear"><a href="#console-trace-，console-clear" class="headerlink" title="console.trace()，console.clear()"></a>console.trace()，console.clear()</h3><p><code>console.trace</code>方法显示当前执行的代码在堆栈中的调用路径。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">trace</span>()</span><br><span class="line"><span class="comment">// console.trace()</span></span><br><span class="line"><span class="comment">//   (anonymous function)</span></span><br><span class="line"><span class="comment">//   InjectedScript._evaluateOn</span></span><br><span class="line"><span class="comment">//   InjectedScript._evaluateAndWrap</span></span><br><span class="line"><span class="comment">//   InjectedScript.evaluate</span></span><br></pre></td></tr></table></figure>

<p><code>console.clear</code>方法用于清除当前控制台的所有输出，将光标回置到第一行。如果用户选中了控制台的“Preserve log”选项，<code>console.clear</code>方法将不起作用。</p>
<h2 id="Object-对象"><a href="#Object-对象" class="headerlink" title="Object 对象"></a><span class="exturl" data-url="aHR0cHM6Ly93YW5nZG9jLmNvbS9qYXZhc2NyaXB0L3N0ZGxpYi9vYmplY3QuaHRtbA==">Object 对象<i class="fa fa-external-link-alt"></i></span></h2><h3 id="Object-keys-，Object-getOwnPropertyNames"><a href="#Object-keys-，Object-getOwnPropertyNames" class="headerlink" title="Object.keys()，Object.getOwnPropertyNames()"></a>Object.keys()，Object.getOwnPropertyNames()</h3><p><code>Object.keys</code>方法的参数是一个对象，返回一个数组。该数组的成员都是该对象自身的（而不是继承的）所有属性名。</p>
<p><code>Object.getOwnPropertyNames</code>方法与<code>Object.keys</code>类似，也是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名。</p>
<p>对于一般的对象来说，<code>Object.keys()</code>和<code>Object.getOwnPropertyNames()</code>返回的结果是一样的。只有涉及不可枚举属性时，才会有不一样的结果。<code>Object.keys</code>方法只返回可枚举的属性（详见《对象属性的描述对象》一章），<code>Object.getOwnPropertyNames</code>方法还返回不可枚举的属性名。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;World&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(a) <span class="comment">// [&quot;0&quot;, &quot;1&quot;]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(a) <span class="comment">// [&quot;0&quot;, &quot;1&quot;, &quot;length&quot;]</span></span><br></pre></td></tr></table></figure>

<h2 id="属性描述对象"><a href="#属性描述对象" class="headerlink" title="属性描述对象"></a><span class="exturl" data-url="aHR0cHM6Ly93YW5nZG9jLmNvbS9qYXZhc2NyaXB0L3N0ZGxpYi9hdHRyaWJ1dGVzLmh0bWw=">属性描述对象<i class="fa fa-external-link-alt"></i></span></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">get</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">set</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>Object.getOwnPropertyDescriptor()</li>
</ol>
<p><code>Object.getOwnPropertyDescriptor()</code>方法只能用于对象自身的属性，不能用于继承的属性。</p>
<ol start="2">
<li><p>Object.getOwnPropertyNames()</p>
</li>
<li><p>Object.defineProperty()，Object.defineProperties()</p>
</li>
</ol>
<p><code>Object.defineProperty(object, propertyName, attributesObject)</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(&#123;&#125;, <span class="string">&#x27;p&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.<span class="property">p</span> <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">obj.<span class="property">p</span> = <span class="number">246</span>;</span><br><span class="line">obj.<span class="property">p</span> <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">p1</span>: &#123; <span class="attr">value</span>: <span class="number">123</span>, <span class="attr">enumerable</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  <span class="attr">p2</span>: &#123; <span class="attr">value</span>: <span class="string">&#x27;abc&#x27;</span>, <span class="attr">enumerable</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  <span class="attr">p3</span>: &#123; <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">p1</span> + <span class="variable language_">this</span>.<span class="property">p2</span> &#125;,</span><br><span class="line">    <span class="attr">enumerable</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>:<span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.<span class="property">p1</span> <span class="comment">// 123</span></span><br><span class="line">obj.<span class="property">p2</span> <span class="comment">// &quot;abc&quot;</span></span><br><span class="line">obj.<span class="property">p3</span> <span class="comment">// &quot;123abc&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>Object.defineProperty()</code>和<code>Object.defineProperties()</code>参数里面的属性描述对象，<code>writable</code>、<code>configurable</code>、<code>enumerable</code>这三个属性的默认值都为<code>false</code>。</p>
<ol start="4">
<li>Object.prototype.propertyIsEnumerable()</li>
</ol>
<p>这个方法只能用于判断对象自身的属性，对于继承的属性一律返回<code>false</code>。</p>
<ol start="5">
<li>对象的拷贝</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> extend = <span class="keyword">function</span> (<span class="params">to, <span class="keyword">from</span></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> property <span class="keyword">in</span> <span class="keyword">from</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">from</span>.<span class="title function_">hasOwnProperty</span>(property)) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(</span><br><span class="line">      to,</span><br><span class="line">      property,</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(<span class="keyword">from</span>, property)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> to;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">extend</span>(&#123;&#125;, &#123; <span class="keyword">get</span> <span class="title function_">a</span>()&#123; <span class="keyword">return</span> <span class="number">1</span> &#125; &#125;)</span><br><span class="line"><span class="comment">// &#123; get a()&#123; return 1 &#125; &#125;)</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>Object.preventExtensions()，Object.isExtensible()</li>
</ol>
<p><code>Object.preventExtensions</code>方法可以使得一个对象无法再添加新的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(obj);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;p&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// TypeError: Cannot define property:p, object is not extensible.</span></span><br><span class="line"></span><br><span class="line">obj.<span class="property">p</span> = <span class="number">1</span>;</span><br><span class="line">obj.<span class="property">p</span> <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(obj) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(obj);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(obj) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>Object.seal()，Object.isSealed()</li>
</ol>
<p><code>Object.seal</code>方法使得一个对象既无法添加新属性，也无法删除旧属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="string">&#x27;hello&#x27;</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">seal</span>(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">p</span>;</span><br><span class="line">obj.<span class="property">p</span> <span class="comment">// &quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">obj.<span class="property">x</span> = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">obj.<span class="property">x</span> <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p><code>Object.seal</code>实质是把属性描述对象的<code>configurable</code>属性设为<code>false</code>，因此属性描述对象不再能改变了。</p>
<ol start="8">
<li>Object.freeze()，Object.isFrozen()</li>
</ol>
<p><code>Object.freeze</code>方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">p</span>: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">freeze</span>(obj);</span><br><span class="line"></span><br><span class="line">obj.<span class="property">p</span> = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">obj.<span class="property">p</span> <span class="comment">// &quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">obj.<span class="property">t</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">obj.<span class="property">t</span> <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">p</span> <span class="comment">// false</span></span><br><span class="line">obj.<span class="property">p</span> <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="实例对象与-new-命令"><a href="#实例对象与-new-命令" class="headerlink" title="实例对象与 new 命令"></a><span class="exturl" data-url="aHR0cHM6Ly93YW5nZG9jLmNvbS9qYXZhc2NyaXB0L29vcC9uZXcuaHRtbA==">实例对象与 new 命令<i class="fa fa-external-link-alt"></i></span></h2><h3 id="new-命令的原理"><a href="#new-命令的原理" class="headerlink" title="new 命令的原理"></a>new 命令的原理</h3><p>使用new命令时，它后面的函数依次执行下面的步骤。</p>
<ol>
<li>创建一个空对象，作为将要返回的对象实例。</li>
<li>将这个空对象的原型，指向构造函数的prototype属性。</li>
<li>将这个空对象赋值给函数内部的this关键字。</li>
<li>开始执行构造函数内部的代码。</li>
</ol>
<p>如果构造函数内部有<code>return</code>语句，而且<code>return</code>后面跟着一个对象，<code>new</code>命令会返回<code>return</code>语句指定的对象；否则，就会不管<code>return</code>语句，返回<code>this</code>对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Vehicle</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">price</span> = <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">new</span> <span class="title class_">Vehicle</span>()) === <span class="number">1000</span></span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，构造函数<code>Vehicle</code>的<code>return</code>语句返回一个数值。这时，<code>new</code>命令就会忽略这个<code>return</code>语句，返回“构造”后的<code>this</code>对象。</p>
<p>但是，如果<code>return</code>语句返回的是一个跟<code>this</code>无关的新对象，<code>new</code>命令会返回这个新对象，而不是<code>this</code>对象。这一点需要特别引起注意。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Vehicle</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">price</span> = <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">price</span>: <span class="number">2000</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">new</span> <span class="title class_">Vehicle</span>()).<span class="property">price</span></span><br><span class="line"><span class="comment">// 2000</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，构造函数<code>Vehicle</code>的<code>return</code>语句，返回的是一个新对象。<code>new</code>命令会返回这个对象，而不是<code>this</code>对象。</p>
<p>另一方面，如果对普通函数（内部没有<code>this</code>关键字的函数）使用<code>new</code>命令，则会返回一个空对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;this is a message&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> msg = <span class="keyword">new</span> <span class="title function_">getMessage</span>();</span><br><span class="line"></span><br><span class="line">msg <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="keyword">typeof</span> msg <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>getMessage</code>是一个普通函数，返回一个字符串。对它使用<code>new</code>命令，会得到一个空对象。这是因为<code>new</code>命令总是返回一个对象，要么是实例对象，要么是<code>return</code>语句指定的对象。本例中，<code>return</code>语句返回的是字符串，所以<code>new</code>命令就忽略了该语句。</p>
<p><code>new</code>命令简化的内部流程，可以用下面的代码表示。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_new</span>(<span class="params"><span class="comment">/* 构造函数 */</span> constructor, <span class="comment">/* 构造函数参数 */</span> params</span>) &#123;</span><br><span class="line">  <span class="comment">// 将 arguments 对象转为数组</span></span><br><span class="line">  <span class="keyword">var</span> args = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="comment">// 取出构造函数</span></span><br><span class="line">  <span class="keyword">var</span> constructor = args.<span class="title function_">shift</span>();</span><br><span class="line">  <span class="comment">// 创建一个空对象，继承构造函数的 prototype 属性</span></span><br><span class="line">  <span class="keyword">var</span> context = <span class="title class_">Object</span>.<span class="title function_">create</span>(constructor.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  <span class="comment">// 执行构造函数</span></span><br><span class="line">  <span class="keyword">var</span> result = constructor.<span class="title function_">apply</span>(context, args);</span><br><span class="line">  <span class="comment">// 如果返回结果是对象，就直接返回，否则返回 context 对象</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span> &amp;&amp; result != <span class="literal">null</span>) ? result : context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例</span></span><br><span class="line"><span class="keyword">var</span> actor = <span class="title function_">_new</span>(<span class="title class_">Person</span>, <span class="string">&#x27;张三&#x27;</span>, <span class="number">28</span>);</span><br></pre></td></tr></table></figure>

<h3 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h3><p>函数内部可以使用<code>new.target</code>属性。如果当前函数是<code>new</code>命令调用，<code>new.target</code>指向当前函数，否则为<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span>.<span class="property">target</span> === f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// false</span></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">f</span>() <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>使用这个属性，可以判断函数调用的时候，是否使用<code>new</code>命令。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">new</span>.<span class="property">target</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;请使用 new 命令调用！&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// Uncaught Error: 请使用 new 命令调用！</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，构造函数<code>f</code>调用时，没有使用<code>new</code>命令，就抛出一个错误。</p>
<h3 id="Object-create-创建实例对象"><a href="#Object-create-创建实例对象" class="headerlink" title="Object.create() 创建实例对象"></a>Object.create() 创建实例对象</h3><p>构造函数作为模板，可以生成实例对象。但是，有时拿不到构造函数，只能拿到一个现有的对象。我们希望以这个现有的对象作为模板，生成新的实例对象，这时就可以使用<code>Object.create()</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">38</span>,</span><br><span class="line">  <span class="attr">greeting</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi! I\&#x27;m &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="title class_">Object</span>.<span class="title function_">create</span>(person1);</span><br><span class="line"></span><br><span class="line">person2.<span class="property">name</span> <span class="comment">// 张三</span></span><br><span class="line">person2.<span class="title function_">greeting</span>() <span class="comment">// Hi! I&#x27;m 张三.</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>person1</code>是<code>person2</code>的模板，后者继承了前者的属性和方法。</p>
<h2 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h2><h3 id="绑定-this-的方法"><a href="#绑定-this-的方法" class="headerlink" title="绑定 this 的方法"></a>绑定 this 的方法</h3><p><code>this</code>的动态切换，固然为 JavaScript 创造了巨大的灵活性，但也使得编程变得困难和模糊。有时，需要把<code>this</code>固定下来，避免出现意想不到的情况。JavaScript 提供了<code>call</code>、<code>apply</code>、<code>bind</code>这三个方法，来切换&#x2F;固定<code>this</code>的指向。</p>
<h3 id="Function-prototype-call"><a href="#Function-prototype-call" class="headerlink" title="Function.prototype.call()"></a>Function.prototype.call()</h3><p>函数实例的<code>call</code>方法，可以指定函数内部<code>this</code>的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>() === <span class="variable language_">window</span> <span class="comment">// true</span></span><br><span class="line">f.<span class="title function_">call</span>(obj) === obj <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，全局环境运行函数<code>f</code>时，<code>this</code>指向全局环境（浏览器为<code>window</code>对象）；<code>call</code>方法可以改变<code>this</code>的指向，指定<code>this</code>指向对象<code>obj</code>，然后在对象<code>obj</code>的作用域中运行函数<code>f</code>。</p>
<p><code>call</code>方法的参数，应该是一个对象。如果参数为空、<code>null</code>和<code>undefined</code>，则默认传入全局对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">n</span>: <span class="number">456</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">n</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.<span class="title function_">call</span>() <span class="comment">// 123</span></span><br><span class="line">a.<span class="title function_">call</span>(<span class="literal">null</span>) <span class="comment">// 123</span></span><br><span class="line">a.<span class="title function_">call</span>(<span class="literal">undefined</span>) <span class="comment">// 123</span></span><br><span class="line">a.<span class="title function_">call</span>(<span class="variable language_">window</span>) <span class="comment">// 123</span></span><br><span class="line">a.<span class="title function_">call</span>(obj) <span class="comment">// 456</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>a</code>函数中的<code>this</code>关键字，如果指向全局对象，返回结果为<code>123</code>。如果使用<code>call</code>方法将<code>this</code>关键字指向<code>obj</code>对象，返回结果为<code>456</code>。可以看到，如果<code>call</code>方法没有参数，或者参数为<code>null</code>或<code>undefined</code>，则等同于指向全局对象。</p>
<p>如果<code>call</code>方法的参数是一个原始值，那么这个原始值会自动转成对应的包装对象，然后传入<code>call</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">f.<span class="title function_">call</span>(<span class="number">5</span>)</span><br><span class="line"><span class="comment">// Number &#123;[[PrimitiveValue]]: 5&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>call</code>的参数为<code>5</code>，不是对象，会被自动转成包装对象（<code>Number</code>的实例），绑定<code>f</code>内部的<code>this</code>。</p>
<p><code>call</code>方法还可以接受多个参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func.<span class="title function_">call</span>(thisValue, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>

<p><code>call</code>的第一个参数就是<code>this</code>所要指向的那个对象，后面的参数则是函数调用时所需的参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add.<span class="title function_">call</span>(<span class="variable language_">this</span>, <span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>call</code>方法指定函数<code>add</code>内部的<code>this</code>绑定当前环境（对象），并且参数为<code>1</code>和<code>2</code>，因此函数<code>add</code>运行后得到<code>3</code>。</p>
<p><code>call</code>方法的一个应用是调用对象的原生方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;toString&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆盖掉继承的 hasOwnProperty 方法</span></span><br><span class="line">obj.<span class="property">hasOwnProperty</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;toString&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hasOwnProperty</span>.<span class="title function_">call</span>(obj, <span class="string">&#x27;toString&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>hasOwnProperty</code>是<code>obj</code>对象继承的方法，如果这个方法一旦被覆盖，就不会得到正确结果。<code>call</code>方法可以解决这个问题，它将<code>hasOwnProperty</code>方法的原始定义放到<code>obj</code>对象上执行，这样无论<code>obj</code>上有没有同名方法，都不会影响结果。</p>
<h3 id="Function-prototype-apply"><a href="#Function-prototype-apply" class="headerlink" title="Function.prototype.apply()"></a>Function.prototype.apply()</h3><p><code>apply</code>方法的作用与<code>call</code>方法类似，也是改变<code>this</code>指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func.<span class="title function_">apply</span>(thisValue, [arg1, arg2, ...])</span><br></pre></td></tr></table></figure>

<p><code>apply</code>方法的第一个参数也是<code>this</code>所要指向的那个对象，如果设为<code>null</code>或<code>undefined</code>，则等同于指定全局对象。第二个参数则是一个数组，该数组的所有成员依次作为参数，传入原函数。原函数的参数，在<code>call</code>方法中必须一个个添加，但是在<code>apply</code>方法中，必须以数组形式添加。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x, y</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x + y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.<span class="title function_">call</span>(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 2</span></span><br><span class="line">f.<span class="title function_">apply</span>(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">1</span>]) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>f</code>函数本来接受两个参数，使用<code>apply</code>方法以后，就变成可以接受一个数组作为参数。</p>
<p>利用这一点，可以做一些有趣的应用。</p>
<p><strong>（1）找出数组最大元素</strong></p>
<p>JavaScript 不提供找出数组最大元素的函数。结合使用<code>apply</code>方法和<code>Math.max</code>方法，就可以返回数组的最大元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">10</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">9</span>];</span><br><span class="line"><span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, a) <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）将数组的空元素变为<code>undefined</code></strong></p>
<p>通过<code>apply</code>方法，利用<code>Array</code>构造函数将数组的空元素变成<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, [<span class="string">&#x27;a&#x27;</span>, ,<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, undefined, &#x27;b&#x27; ]</span></span><br></pre></td></tr></table></figure>

<p>空元素与<code>undefined</code>的差别在于，数组的<code>forEach</code>方法会跳过空元素，但是不会跳过<code>undefined</code>。因此，遍历内部元素的时候，会得到不同的结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;a&#x27;</span>, , <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">print</span>(<span class="params">i</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.<span class="title function_">forEach</span>(print)</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, a).<span class="title function_">forEach</span>(print)</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// b</span></span><br></pre></td></tr></table></figure>

<p><strong>（3）转换类似数组的对象</strong></p>
<p>另外，利用数组对象的<code>slice</code>方法，可以将一个类似数组的对象（比如<code>arguments</code>对象）转为真正的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">apply</span>(&#123;<span class="number">0</span>: <span class="number">1</span>, <span class="attr">length</span>: <span class="number">1</span>&#125;) <span class="comment">// [1]</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">apply</span>(&#123;<span class="number">0</span>: <span class="number">1</span>&#125;) <span class="comment">// []</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">apply</span>(&#123;<span class="number">0</span>: <span class="number">1</span>, <span class="attr">length</span>: <span class="number">2</span>&#125;) <span class="comment">// [1, undefined]</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">apply</span>(&#123;<span class="attr">length</span>: <span class="number">1</span>&#125;) <span class="comment">// [undefined]</span></span><br></pre></td></tr></table></figure>

<p>上面代码的<code>apply</code>方法的参数都是对象，但是返回结果都是数组，这就起到了将对象转成数组的目的。从上面代码可以看到，这个方法起作用的前提是，被处理的对象必须有<code>length</code>属性，以及相对应的数字键。</p>
<p><strong>（4）绑定回调函数的对象</strong></p>
<p>前面的按钮点击事件的例子，可以改写如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">o.<span class="property">f</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">  o.<span class="property">f</span>.<span class="title function_">apply</span>(o);</span><br><span class="line">  <span class="comment">// 或者 o.f.call(o);</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jQuery 的写法</span></span><br><span class="line">$(<span class="string">&#x27;#button&#x27;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, f);</span><br></pre></td></tr></table></figure>

<p>上面代码中，点击按钮以后，控制台将会显示<code>true</code>。由于<code>apply()</code>方法（或者<code>call()</code>方法）不仅绑定函数执行时所在的对象，还会立即执行函数，因此不得不把绑定语句写在一个函数体内。更简洁的写法是采用下面介绍的<code>bind()</code>方法。</p>
<h3 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind()"></a>Function.prototype.bind()</h3><p><code>bind()</code>方法用于将函数体内的<code>this</code>绑定到某个对象，然后返回一个新函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">d.<span class="title function_">getTime</span>() <span class="comment">// 1481869925657</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> print = d.<span class="property">getTime</span>;</span><br><span class="line"><span class="title function_">print</span>() <span class="comment">// Uncaught TypeError: this is not a Date object.</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，我们将<code>d.getTime()</code>方法赋给变量<code>print</code>，然后调用<code>print()</code>就报错了。这是因为<code>getTime()</code>方法内部的<code>this</code>，绑定<code>Date</code>对象的实例，赋给变量<code>print</code>以后，内部的<code>this</code>已经不指向<code>Date</code>对象的实例了。</p>
<p><code>bind()</code>方法可以解决这个问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> print = d.<span class="property">getTime</span>.<span class="title function_">bind</span>(d);</span><br><span class="line"><span class="title function_">print</span>() <span class="comment">// 1481869925657</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>bind()</code>方法将<code>getTime()</code>方法内部的<code>this</code>绑定到<code>d</code>对象，这时就可以安全地将这个方法赋值给其他变量了。</p>
<p><code>bind</code>方法的参数就是所要绑定<code>this</code>的对象，下面是一个更清晰的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">inc</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = counter.<span class="property">inc</span>.<span class="title function_">bind</span>(counter);</span><br><span class="line"><span class="title function_">func</span>();</span><br><span class="line">counter.<span class="property">count</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>counter.inc()</code>方法被赋值给变量<code>func</code>。这时必须用<code>bind()</code>方法将<code>inc()</code>内部的<code>this</code>，绑定到<code>counter</code>，否则就会出错。</p>
<p><code>this</code>绑定到其他对象也是可以的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">inc</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">100</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> func = counter.<span class="property">inc</span>.<span class="title function_">bind</span>(obj);</span><br><span class="line"><span class="title function_">func</span>();</span><br><span class="line">obj.<span class="property">count</span> <span class="comment">// 101</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>bind()</code>方法将<code>inc()</code>方法内部的<code>this</code>，绑定到<code>obj</code>对象。结果调用<code>func</code>函数以后，递增的就是<code>obj</code>内部的<code>count</code>属性。</p>
<p><code>bind()</code>还可以接受更多的参数，将这些参数绑定原函数的参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x * <span class="variable language_">this</span>.<span class="property">m</span> + y * <span class="variable language_">this</span>.<span class="property">n</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">m</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">n</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newAdd = add.<span class="title function_">bind</span>(obj, <span class="number">5</span>);</span><br><span class="line"><span class="title function_">newAdd</span>(<span class="number">5</span>) <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>bind()</code>方法除了绑定<code>this</code>对象，还将<code>add()</code>函数的第一个参数<code>x</code>绑定成<code>5</code>，然后返回一个新函数<code>newAdd()</code>，这个函数只要再接受一个参数<code>y</code>就能运行了。</p>
<p>如果<code>bind()</code>方法的第一个参数是<code>null</code>或<code>undefined</code>，等于将<code>this</code>绑定到全局对象，函数运行时<code>this</code>指向顶层对象（浏览器为<code>window</code>）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> plus5 = add.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="number">5</span>);</span><br><span class="line"><span class="title function_">plus5</span>(<span class="number">10</span>) <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>add()</code>内部并没有<code>this</code>，使用<code>bind()</code>方法的主要目的是绑定参数<code>x</code>，以后每次运行新函数<code>plus5()</code>，就只需要提供另一个参数<code>y</code>就够了。而且因为<code>add()</code>内部没有<code>this</code>，所以<code>bind()</code>的第一个参数是<code>null</code>，不过这里如果是其他对象，也没有影响。</p>
<p><code>bind()</code>方法有一些使用注意点。</p>
<p><strong>（1）每一次返回一个新函数</strong></p>
<p><code>bind()</code>方法每运行一次，就返回一个新函数，这会产生一些问题。比如，监听事件的时候，不能写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, o.<span class="property">m</span>.<span class="title function_">bind</span>(o));</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>click</code>事件绑定<code>bind()</code>方法生成的一个匿名函数。这样会导致无法取消绑定，所以下面的代码是无效的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">element.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, o.<span class="property">m</span>.<span class="title function_">bind</span>(o));</span><br></pre></td></tr></table></figure>

<p>正确的方法是写成下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> listener = o.<span class="property">m</span>.<span class="title function_">bind</span>(o);</span><br><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, listener);</span><br><span class="line"><span class="comment">//  ...</span></span><br><span class="line">element.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, listener);</span><br></pre></td></tr></table></figure>

<p><strong>（2）结合回调函数使用</strong></p>
<p>回调函数是 JavaScript 最常用的模式之一，但是一个常见的错误是，将包含<code>this</code>的方法直接当作回调函数。解决方法就是使用<code>bind()</code>方法，将<code>counter.inc()</code>绑定<code>counter</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">inc</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">callIt</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="title function_">callback</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">callIt</span>(counter.<span class="property">inc</span>.<span class="title function_">bind</span>(counter));</span><br><span class="line">counter.<span class="property">count</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>callIt()</code>方法会调用回调函数。这时如果直接把<code>counter.inc</code>传入，调用时<code>counter.inc()</code>内部的<code>this</code>就会指向全局对象。使用<code>bind()</code>方法将<code>counter.inc</code>绑定<code>counter</code>以后，就不会有这个问题，<code>this</code>总是指向<code>counter</code>。</p>
<p>还有一种情况比较隐蔽，就是某些数组方法可以接受一个函数当作参数。这些函数内部的<code>this</code>指向，很可能也会出错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  <span class="attr">times</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  <span class="attr">print</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">times</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">print</span>()</span><br><span class="line"><span class="comment">// 没有任何输出</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>obj.print</code>内部<code>this.times</code>的<code>this</code>是指向<code>obj</code>的，这个没有问题。但是，<code>forEach()</code>方法的回调函数内部的<code>this.name</code>却是指向全局对象，导致没有办法取到值。稍微改动一下，就可以看得更清楚。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">obj.<span class="property">print</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">times</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === <span class="variable language_">window</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">print</span>()</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>解决这个问题，也是通过<code>bind()</code>方法绑定<code>this</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">obj.<span class="property">print</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">times</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;.<span class="title function_">bind</span>(<span class="variable language_">this</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">print</span>()</span><br><span class="line"><span class="comment">// 张三</span></span><br><span class="line"><span class="comment">// 张三</span></span><br><span class="line"><span class="comment">// 张三</span></span><br></pre></td></tr></table></figure>

<p><strong>（3）结合<code>call()</code>方法使用</strong></p>
<p>利用<code>bind()</code>方法，可以改写一些 JavaScript 原生方法的使用形式，以数组的<code>slice()</code>方法为例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">1</span>) <span class="comment">// [1]</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">0</span>, <span class="number">1</span>) <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中，数组的<code>slice</code>方法从<code>[1, 2, 3]</code>里面，按照指定的开始位置和结束位置，切分出另一个数组。这样做的本质是在<code>[1, 2, 3]</code>上面调用<code>Array.prototype.slice()</code>方法，因此可以用<code>call</code>方法表达这个过程，得到同样的结果。</p>
<p><code>call()</code>方法实质上是调用<code>Function.prototype.call()</code>方法，因此上面的表达式可以用<code>bind()</code>方法改写。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">call</span>.<span class="title function_">bind</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>);</span><br><span class="line"><span class="title function_">slice</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">0</span>, <span class="number">1</span>) <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure>

<p>上面代码的含义就是，将<code>Array.prototype.slice</code>变成<code>Function.prototype.call</code>方法所在的对象，调用时就变成了<code>Array.prototype.slice.call</code>。类似的写法还可以用于其他数组方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> push = <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">call</span>.<span class="title function_">bind</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span>);</span><br><span class="line"><span class="keyword">var</span> pop = <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">call</span>.<span class="title function_">bind</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pop</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span> ,<span class="number">2</span> ,<span class="number">3</span>];</span><br><span class="line"><span class="title function_">push</span>(a, <span class="number">4</span>)</span><br><span class="line">a <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">pop</span>(a)</span><br><span class="line">a <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>如果再进一步，将<code>Function.prototype.call</code>方法绑定到<code>Function.prototype.bind</code>对象，就意味着<code>bind</code>的调用形式也可以被改写。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">v</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">v</span>: <span class="number">123</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> bind = <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">call</span>.<span class="title function_">bind</span>(<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span>);</span><br><span class="line"><span class="title function_">bind</span>(f, o)() <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<p>上面代码的含义就是，将<code>Function.prototype.bind</code>方法绑定在<code>Function.prototype.call</code>上面，所以<code>bind</code>方法就可以直接使用，不需要在函数实例上使用。</p>
<h2 id="对象的继承"><a href="#对象的继承" class="headerlink" title="对象的继承"></a><span class="exturl" data-url="aHR0cHM6Ly93YW5nZG9jLmNvbS9qYXZhc2NyaXB0L29vcC9wcm90b3R5cGUuaHRtbA==">对象的继承<i class="fa fa-external-link-alt"></i></span></h2><h3 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h3><p><code>instanceof</code>运算符返回一个布尔值，表示对象是否为某个构造函数的实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> <span class="title class_">Vehicle</span>();</span><br><span class="line">v <span class="keyword">instanceof</span> <span class="title class_">Vehicle</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>v</code>是构造函数<code>Vehicle</code>的实例，所以返回<code>true</code>。</p>
<p><code>instanceof</code>运算符的左边是实例对象，右边是构造函数。它会检查右边构造函数的原型对象（prototype），是否在左边对象的原型链上。因此，下面两种写法是等价的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">v <span class="keyword">instanceof</span> <span class="title class_">Vehicle</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="title class_">Vehicle</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(v)</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Vehicle</code>是对象<code>v</code>的构造函数，它的原型对象是<code>Vehicle.prototype</code>，<code>isPrototypeOf()</code>方法是 JavaScript 提供的原生方法，用于检查某个对象是否为另一个对象的原型，详细解释见后文。</p>
<p>由于<code>instanceof</code>检查整个原型链，因此同一个实例对象，可能会对多个构造函数都返回<code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">d <span class="keyword">instanceof</span> <span class="title class_">Date</span> <span class="comment">// true</span></span><br><span class="line">d <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>d</code>同时是<code>Date</code>和<code>Object</code>的实例，因此对这两个构造函数都返回<code>true</code>。</p>
<p>由于任意对象（除了<code>null</code>）都是<code>Object</code>的实例，所以<code>instanceof</code>运算符可以判断一个值是否为非<code>null</code>的对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，除了<code>null</code>，其他对象的<code>instanceOf Object</code>的运算结果都是<code>true</code>。</p>
<p><code>instanceof</code>的原理是检查右边构造函数的<code>prototype</code>属性，是否在左边对象的原型链上。有一种特殊情况，就是左边对象的原型链上，只有<code>null</code>对象。这时，<code>instanceof</code>判断会失真。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">typeof</span> obj <span class="comment">// &quot;object&quot;</span></span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Object.create(null)</code>返回一个新对象<code>obj</code>，它的原型是<code>null</code>（<code>Object.create()</code>的详细介绍见后文）。右边的构造函数<code>Object</code>的<code>prototype</code>属性，不在左边的原型链上，因此<code>instanceof</code>就认为<code>obj</code>不是<code>Object</code>的实例。这是唯一的<code>instanceof</code>运算符判断会失真的情况（一个对象的原型是<code>null</code>）。</p>
<p><code>instanceof</code>运算符的一个用处，是判断值的类型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> y = &#123;&#125;;</span><br><span class="line">x <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">// true</span></span><br><span class="line">y <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>instanceof</code>运算符判断，变量<code>x</code>是数组，变量<code>y</code>是对象。</p>
<p>注意，<code>instanceof</code>运算符只能用于对象，不适用原始类型的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">s <span class="keyword">instanceof</span> <span class="title class_">String</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，字符串不是<code>String</code>对象的实例（因为字符串不是对象），所以返回<code>false</code>。</p>
<p>此外，对于<code>undefined</code>和<code>null</code>，<code>instanceof</code>运算符总是返回<code>false</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">undefined</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>利用<code>instanceof</code>运算符，还可以巧妙地解决，调用构造函数时，忘了加<code>new</code>命令的问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fubar</span> (foo, bar) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Fubar</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_foo</span> = foo;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_bar</span> = bar;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fubar</span>(foo, bar);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码使用<code>instanceof</code>运算符，在函数体内部判断<code>this</code>关键字是否为构造函数<code>Fubar</code>的实例。如果不是，就表明忘了加<code>new</code>命令。</p>
<h3 id="构造函数的继承"><a href="#构造函数的继承" class="headerlink" title="构造函数的继承"></a>构造函数的继承</h3><p>让一个构造函数继承另一个构造函数，是非常常见的需求。这可以分成两步实现。第一步是在子类的构造函数中，调用父类的构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Sub</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="title class_">Super</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">prop</span> = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Sub</code>是子类的构造函数，<code>this</code>是子类的实例。在实例上调用父类的构造函数<code>Super</code>，就会让子类实例具有父类实例的属性。</p>
<p>第二步，是让子类的原型指向父类的原型，这样子类就可以继承父类原型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Super</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Sub</span>;</span><br><span class="line"><span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">method</span> = <span class="string">&#x27;...&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Sub.prototype</code>是子类的原型，要将它赋值为<code>Object.create(Super.prototype)</code>，而不是直接等于<code>Super.prototype</code>。否则后面两行对<code>Sub.prototype</code>的操作，会连父类的原型<code>Super.prototype</code>一起修改掉。</p>
<p>另外一种写法是<code>Sub.prototype</code>等于一个父类实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Super</span>();</span><br></pre></td></tr></table></figure>

<p>上面这种写法也有继承的效果，但是子类会具有父类实例的方法。有时，这可能不是我们需要的，所以不推荐使用这种写法。</p>
<p>举例来说，下面是一个<code>Shape</code>构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Shape</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">y</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Shape</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">move</span> = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">x</span> += x;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">y</span> += y;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&#x27;Shape moved.&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们需要让<code>Rectangle</code>构造函数继承<code>Shape</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一步，子类继承父类的实例</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Rectangle</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Shape</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>); <span class="comment">// 调用父类构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Rectangle</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">base</span> = <span class="title class_">Shape</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">base</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步，子类继承父类的原型</span></span><br><span class="line"><span class="title class_">Rectangle</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Shape</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">Rectangle</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Rectangle</span>;</span><br></pre></td></tr></table></figure>

<p>采用这样的写法以后，<code>instanceof</code>运算符会对子类和父类的构造函数，都返回<code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rect = <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line"></span><br><span class="line">rect <span class="keyword">instanceof</span> <span class="title class_">Rectangle</span>  <span class="comment">// true</span></span><br><span class="line">rect <span class="keyword">instanceof</span> <span class="title class_">Shape</span>  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，子类是整体继承父类。有时只需要单个方法的继承，这时可以采用下面的写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">ClassB</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">print</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">ClassA</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">print</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，子类<code>B</code>的<code>print</code>方法先调用父类<code>A</code>的<code>print</code>方法，再部署自己的代码。这就等于继承了父类<code>A</code>的<code>print</code>方法。</p>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>JavaScript 不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过变通方法，实现这个功能。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">M1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">hello</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">M2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">world</span> = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">S</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable constant_">M1</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="variable constant_">M2</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承 M1</span></span><br><span class="line">S.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="variable constant_">M1</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="comment">// 继承链上加入 M2</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(S.<span class="property"><span class="keyword">prototype</span></span>, <span class="variable constant_">M2</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定构造函数</span></span><br><span class="line">S.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = S;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="title function_">S</span>();</span><br><span class="line">s.<span class="property">hello</span> <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line">s.<span class="property">world</span> <span class="comment">// &#x27;world&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，子类<code>S</code>同时继承了父类<code>M1</code>和<code>M2</code>。这种模式又称为 Mixin（混入）。</p>
<h2 id="Object-对象的相关方法"><a href="#Object-对象的相关方法" class="headerlink" title="Object 对象的相关方法"></a><span class="exturl" data-url="aHR0cHM6Ly93YW5nZG9jLmNvbS9qYXZhc2NyaXB0L29vcC9vYmplY3QuaHRtbA==">Object 对象的相关方法<i class="fa fa-external-link-alt"></i></span></h2><h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h3><p><code>Object.getPrototypeOf</code>方法返回参数对象的原型。这是获取原型对象的标准方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(f) === F.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，实例对象<code>f</code>的原型是<code>F.prototype</code>。</p>
<p>下面是几种特殊对象的原型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空对象的原型是 Object.prototype</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(&#123;&#125;) === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.prototype 的原型是 null</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>) === <span class="literal">null</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的原型是 Function.prototype</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(f) === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h3><p><code>Object.setPrototypeOf</code>方法为参数对象设置原型，返回该参数对象。它接受两个参数，第一个是现有对象，第二个是原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> b = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(a, b);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(a) === b <span class="comment">// true</span></span><br><span class="line">a.<span class="property">x</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Object.setPrototypeOf</code>方法将对象<code>a</code>的原型，设置为对象<code>b</code>，因此<code>a</code>可以共享<code>b</code>的属性。</p>
<p><code>new</code>命令可以使用<code>Object.setPrototypeOf</code>方法模拟。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">foo</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(&#123;&#125;, F.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">F.<span class="title function_">call</span>(f);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>new</code>命令新建实例对象，其实可以分成两步。第一步，将一个空对象的原型设为构造函数的<code>prototype</code>属性（上例是<code>F.prototype</code>）；第二步，将构造函数内部的<code>this</code>绑定这个空对象，然后执行构造函数，使得定义在<code>this</code>上面的方法和属性（上例是<code>this.foo</code>），都转移到这个空对象上。</p>
<h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><p>生成实例对象的常用方法是，使用<code>new</code>命令让构造函数返回一个实例。但是很多时候，只能拿到一个实例对象，它可能根本不是由构建函数生成的，那么能不能从一个实例对象，生成另一个实例对象呢？</p>
<p>JavaScript 提供了<code>Object.create()</code>方法，用来满足这种需求。该方法接受一个对象作为参数，然后以它为原型，返回一个实例对象。该实例完全继承原型对象的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原型对象</span></span><br><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">  <span class="attr">print</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例对象</span></span><br><span class="line"><span class="keyword">var</span> B = <span class="title class_">Object</span>.<span class="title function_">create</span>(A);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(B) === A <span class="comment">// true</span></span><br><span class="line">B.<span class="title function_">print</span>() <span class="comment">// hello</span></span><br><span class="line">B.<span class="property">print</span> === A.<span class="property">print</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Object.create()</code>方法以<code>A</code>对象为原型，生成了<code>B</code>对象。<code>B</code>继承了<code>A</code>的所有属性和方法。</p>
<p>实际上，<code>Object.create()</code>方法可以用下面的代码代替。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">Object</span>.<span class="property">create</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="property">create</span> = <span class="keyword">function</span> (<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">    F.<span class="property"><span class="keyword">prototype</span></span> = obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码表明，<code>Object.create()</code>方法的实质是新建一个空的构造函数<code>F</code>，然后让<code>F.prototype</code>属性指向参数对象<code>obj</code>，最后返回一个<code>F</code>的实例，从而实现让该实例继承<code>obj</code>的属性。</p>
<p>下面三种方式生成的新对象是等价的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = <span class="title class_">Object</span>.<span class="title function_">create</span>(&#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="keyword">var</span> obj3 = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<p>如果想要生成一个不继承任何属性（比如没有<code>toString()</code>和<code>valueOf()</code>方法）的对象，可以将<code>Object.create()</code>的参数设为<code>null</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">valueOf</span>()</span><br><span class="line"><span class="comment">// TypeError: Object [object Object] has no method &#x27;valueOf&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>obj</code>的原型是<code>null</code>，它就不具备一些定义在<code>Object.prototype</code>对象上面的属性，比如<code>valueOf()</code>方法。</p>
<p>使用<code>Object.create()</code>方法的时候，必须提供对象原型，即参数不能为空，或者不是对象，否则会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">create</span>()</span><br><span class="line"><span class="comment">// TypeError: Object prototype may only be an Object or null</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="number">123</span>)</span><br><span class="line"><span class="comment">// TypeError: Object prototype may only be an Object or null</span></span><br></pre></td></tr></table></figure>

<p><code>Object.create()</code>方法生成的新对象，动态继承了原型。在原型上添加或修改任何方法，会立刻反映在新对象之上。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="title class_">Object</span>.<span class="title function_">create</span>(obj1);</span><br><span class="line"></span><br><span class="line">obj1.<span class="property">p</span> = <span class="number">2</span>;</span><br><span class="line">obj2.<span class="property">p</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，修改对象原型<code>obj1</code>会影响到实例对象<code>obj2</code>。</p>
<p>除了对象的原型，<code>Object.create()</code>方法还可以接受第二个参数。该参数是一个属性描述对象，它所描述的对象属性，会添加到实例对象，作为该对象自身的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">p1</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">123</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">p2</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;abc&#x27;</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(&#123;&#125;);</span><br><span class="line">obj.<span class="property">p1</span> = <span class="number">123</span>;</span><br><span class="line">obj.<span class="property">p2</span> = <span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><code>Object.create()</code>方法生成的对象，继承了它的原型对象的构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line"><span class="keyword">var</span> b = <span class="title class_">Object</span>.<span class="title function_">create</span>(a);</span><br><span class="line"></span><br><span class="line">b.<span class="property">constructor</span> === A <span class="comment">// true</span></span><br><span class="line">b <span class="keyword">instanceof</span> A <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>b</code>对象的原型是<code>a</code>对象，因此继承了<code>a</code>对象的构造函数<code>A</code>。</p>
<h3 id="Object-prototype-isPrototypeOf"><a href="#Object-prototype-isPrototypeOf" class="headerlink" title="Object.prototype.isPrototypeOf()"></a>Object.prototype.isPrototypeOf()</h3><p>实例对象的<code>isPrototypeOf</code>方法，用来判断该对象是否为参数对象的原型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="title class_">Object</span>.<span class="title function_">create</span>(o1);</span><br><span class="line"><span class="keyword">var</span> o3 = <span class="title class_">Object</span>.<span class="title function_">create</span>(o2);</span><br><span class="line"></span><br><span class="line">o2.<span class="title function_">isPrototypeOf</span>(o3) <span class="comment">// true</span></span><br><span class="line">o1.<span class="title function_">isPrototypeOf</span>(o3) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>o1</code>和<code>o2</code>都是<code>o3</code>的原型。这表明只要实例对象处在参数对象的原型链上，<code>isPrototypeOf</code>方法都返回<code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(&#123;&#125;) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>([]) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(<span class="regexp">/xyz/</span>) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(<span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，由于<code>Object.prototype</code>处于原型链的最顶端，所以对各种实例都返回<code>true</code>，只有直接继承自<code>null</code>的对象除外。</p>
<h3 id="Object-prototype-proto"><a href="#Object-prototype-proto" class="headerlink" title="Object.prototype.__proto__"></a>Object.prototype.__proto__</h3><p>实例对象的<code>__proto__</code>属性（前后各两个下划线），返回该对象的原型。该属性可读写。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> p = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">__proto__</span> = p;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj) === p <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码通过<code>__proto__</code>属性，将<code>p</code>对象设为<code>obj</code>对象的原型。</p>
<p>根据语言标准，<code>__proto__</code>属性只有浏览器才需要部署，其他环境可以没有这个属性。它前后的两根下划线，表明它本质是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用<code>Object.getPrototypeOf()</code>和<code>Object.setPrototypeOf()</code>，进行原型对象的读写操作。</p>
<p>原型链可以用<code>__proto__</code>很直观地表示。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> B = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;李四&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proto = &#123;</span><br><span class="line">  <span class="attr">print</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A.<span class="property">__proto__</span> = proto;</span><br><span class="line">B.<span class="property">__proto__</span> = proto;</span><br><span class="line"></span><br><span class="line">A.<span class="title function_">print</span>() <span class="comment">// 张三</span></span><br><span class="line">B.<span class="title function_">print</span>() <span class="comment">// 李四</span></span><br><span class="line"></span><br><span class="line">A.<span class="property">print</span> === B.<span class="property">print</span> <span class="comment">// true</span></span><br><span class="line">A.<span class="property">print</span> === proto.<span class="property">print</span> <span class="comment">// true</span></span><br><span class="line">B.<span class="property">print</span> === proto.<span class="property">print</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>A</code>对象和<code>B</code>对象的原型都是<code>proto</code>对象，它们都共享<code>proto</code>对象的<code>print</code>方法。也就是说，<code>A</code>和<code>B</code>的<code>print</code>方法，都是在调用<code>proto</code>对象的<code>print</code>方法。</p>
<h3 id="获取原型对象方法的比较"><a href="#获取原型对象方法的比较" class="headerlink" title="获取原型对象方法的比较"></a>获取原型对象方法的比较</h3><p>如前所述，<code>__proto__</code>属性指向当前对象的原型对象，即构造函数的<code>prototype</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">obj.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">obj.<span class="property">__proto__</span> === obj.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码首先新建了一个对象<code>obj</code>，它的<code>__proto__</code>属性，指向构造函数（<code>Object</code>或<code>obj.constructor</code>）的<code>prototype</code>属性。</p>
<p>因此，获取实例对象<code>obj</code>的原型对象，有三种方法。</p>
<ul>
<li><code>obj.__proto__</code></li>
<li><code>obj.constructor.prototype</code></li>
<li><code>Object.getPrototypeOf(obj)</code></li>
</ul>
<p>上面三种方法之中，前两种都不是很可靠。<code>__proto__</code>属性只有浏览器才需要部署，其他环境可以不部署。而<code>obj.constructor.prototype</code>在手动改变原型对象时，可能会失效。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> P = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title function_">P</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> C = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line">C.<span class="property"><span class="keyword">prototype</span></span> = p;</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line"></span><br><span class="line">c.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span> === p <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，构造函数<code>C</code>的原型对象被改成了<code>p</code>，但是实例对象的<code>c.constructor.prototype</code>却没有指向<code>p</code>。所以，在改变原型对象时，一般要同时设置<code>constructor</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">C.<span class="property"><span class="keyword">prototype</span></span> = p;</span><br><span class="line">C.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = C;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line">c.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span> === p <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>因此，推荐使用第三种<code>Object.getPrototypeOf</code>方法，获取原型对象。</p>
<h3 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h3><p><code>Object.getOwnPropertyNames</code>方法返回一个数组，成员是参数对象本身的所有属性的键名，不包含继承的属性键名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(<span class="title class_">Date</span>)</span><br><span class="line"><span class="comment">// [&quot;parse&quot;, &quot;arguments&quot;, &quot;UTC&quot;, &quot;caller&quot;, &quot;name&quot;, &quot;prototype&quot;, &quot;now&quot;, &quot;length&quot;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Object.getOwnPropertyNames</code>方法返回<code>Date</code>所有自身的属性名。</p>
<p>对象本身的属性之中，有的是可以遍历的（enumerable），有的是不可以遍历的。<code>Object.getOwnPropertyNames</code>方法返回所有键名，不管是否可以遍历。只获取那些可以遍历的属性，使用<code>Object.keys</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">Date</span>) <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<p>上面代码表明，<code>Date</code>对象所有自身的属性，都是不可以遍历的。</p>
<h3 id="Object-prototype-hasOwnProperty"><a href="#Object-prototype-hasOwnProperty" class="headerlink" title="Object.prototype.hasOwnProperty()"></a>Object.prototype.hasOwnProperty()</h3><p>对象实例的<code>hasOwnProperty</code>方法返回一个布尔值，用于判断某个属性定义在对象自身，还是定义在原型链上。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Date</span>.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;length&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Date</span>.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;toString&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码表明，<code>Date.length</code>（构造函数<code>Date</code>可以接受多少个参数）是<code>Date</code>自身的属性，<code>Date.toString</code>是继承的属性。</p>
<p>另外，<code>hasOwnProperty</code>方法是 JavaScript 之中唯一一个处理对象属性时，不会遍历原型链的方法。</p>
<h2 id="in-运算符和-for…in-循环"><a href="#in-运算符和-for…in-循环" class="headerlink" title="in 运算符和 for…in 循环"></a>in 运算符和 for…in 循环</h2><p><code>in</code>运算符返回一个布尔值，表示一个对象是否具有某个属性。它不区分该属性是对象自身的属性，还是继承的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;length&#x27;</span> <span class="keyword">in</span> <span class="title class_">Date</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> <span class="title class_">Date</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>in</code>运算符常用于检查一个属性是否存在。</p>
<p>获得对象的所有可遍历属性（不管是自身的还是继承的），可以使用<code>for...in</code>循环。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">p1</span>: <span class="number">123</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o2 = <span class="title class_">Object</span>.<span class="title function_">create</span>(o1, &#123;</span><br><span class="line">  <span class="attr">p2</span>: &#123; <span class="attr">value</span>: <span class="string">&quot;abc&quot;</span>, <span class="attr">enumerable</span>: <span class="literal">true</span> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (p <span class="keyword">in</span> o2) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">info</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// p2</span></span><br><span class="line"><span class="comment">// p1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>o2</code>的<code>p2</code>属性是自身的，<code>p1</code>属性是继承的。这两个属性都会被<code>for...in</code>循环遍历。</p>
<p>为了在<code>for...in</code>循环中获得对象自身的属性，可以采用<code>hasOwnProperty</code>方法判断一下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> name <span class="keyword">in</span> object ) &#123;</span><br><span class="line">  <span class="keyword">if</span> ( object.<span class="title function_">hasOwnProperty</span>(name) ) &#123;</span><br><span class="line">    <span class="comment">/* loop code */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获得对象的所有属性（不管是自身的还是继承的，也不管是否可枚举），可以使用下面的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inheritedPropertyNames</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> props = &#123;&#125;;</span><br><span class="line">  <span class="keyword">while</span>(obj) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(obj).<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">p</span>) &#123;</span><br><span class="line">      props[p] = <span class="literal">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    obj = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码依次获取<code>obj</code>对象的每一级原型对象“自身”的属性，从而获取<code>obj</code>对象的“所有”属性，不管是否可遍历。</p>
<p>下面是一个例子，列出<code>Date</code>对象的所有属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">inheritedPropertyNames</span>(<span class="title class_">Date</span>)</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//  &quot;caller&quot;,</span></span><br><span class="line"><span class="comment">//  &quot;constructor&quot;,</span></span><br><span class="line"><span class="comment">//  &quot;toString&quot;,</span></span><br><span class="line"><span class="comment">//  &quot;UTC&quot;,</span></span><br><span class="line"><span class="comment">//  ...</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure>

<h3 id="对象的拷贝"><a href="#对象的拷贝" class="headerlink" title="对象的拷贝"></a>对象的拷贝</h3><p>如果要拷贝一个对象，需要做到下面两件事情。</p>
<ul>
<li>确保拷贝后的对象，与原对象具有同样的原型。</li>
<li>确保拷贝后的对象，与原对象具有同样的实例属性。</li>
</ul>
<p>下面就是根据上面两点，实现的对象拷贝函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">copyObject</span>(<span class="params">orig</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> copy = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(orig));</span><br><span class="line">  <span class="title function_">copyOwnPropertiesFrom</span>(copy, orig);</span><br><span class="line">  <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">copyOwnPropertiesFrom</span>(<span class="params">target, source</span>) &#123;</span><br><span class="line">  <span class="title class_">Object</span></span><br><span class="line">    .<span class="title function_">getOwnPropertyNames</span>(source)</span><br><span class="line">    .<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">propKey</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> desc = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(source, propKey);</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, propKey, desc);</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种更简单的写法，是利用 ES2017 才引入标准的<code>Object.getOwnPropertyDescriptors</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">copyObject</span>(<span class="params">orig</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">create</span>(</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(orig),</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(orig)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
